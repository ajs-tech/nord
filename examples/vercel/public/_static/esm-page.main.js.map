{
  "version": 3,
  "sources": ["../../core/src/utils/util.ts", "../../core/src/formula/formulaTypes.ts", "../../core/src/formula/formula.ts", "../../core/src/utils/collections.ts", "../../core/src/utils/hash.ts", "../../core/src/api/apiTypes.ts", "../../core/src/formula/formulaUtils.ts", "../../core/src/api/LegacyToddleApi.ts", "../../core/src/component/actionUtils.ts", "../../core/src/api/ToddleApiV2.ts", "../../core/src/api/api.ts", "../../core/src/utils/json.ts", "../../core/src/api/template.ts", "../../../node_modules/fast-deep-equal/index.js", "../../core/src/api/headers.ts", "../../core/src/utils/url.ts", "../../core/src/styling/className.ts", "../src/page.main.ts", "../../lib/actions.ts", "../../lib/actions/sleep/handler.ts", "../../lib/actions/deleteFromLocalStorage/handler.ts", "../../lib/actions/share/handler.ts", "../../lib/actions/saveToSessionStorage/handler.ts", "../../lib/actions/preventDefault/handler.ts", "../../lib/actions/interval/handler.ts", "../../lib/actions/clearLocalStorage/handler.ts", "../../lib/actions/deleteFromSessionStorage/handler.ts", "../../lib/actions/logToConsole/handler.ts", "../../lib/actions/copyToClipboard/handler.ts", "../../lib/actions/setSessionCookies/handler.ts", "../../lib/actions/saveToLocalStorage/handler.ts", "../../lib/actions/focus/handler.ts", "../../lib/actions/clearSessionStorage/handler.ts", "../../lib/actions/gotToURL/handler.ts", "../../lib/actions/stopPropagation/handler.ts", "../../lib/formulas.ts", "../../lib/formulas/notEqual/handler.ts", "../../lib/formulas/findLast/handler.ts", "../../lib/formulas/userAgent/handler.ts", "../../lib/formulas/round/handler.ts", "../../lib/formulas/defaultTo/handler.ts", "../../lib/formulas/multiply/handler.ts", "../../lib/formulas/randomNumber/handler.ts", "../../lib/formulas/reduce/handler.ts", "../../lib/formulas/includes/handler.ts", "../../lib/formulas/min/handler.ts", "../../lib/formulas/uppercase/handler.ts", "../../lib/formulas/encodeURIComponent/handler.ts", "../../lib/formulas/sort_by/handler.ts", "../../lib/formulas/some/handler.ts", "../../lib/formulas/roundUp/handler.ts", "../../lib/formulas/not/handler.ts", "../../lib/formulas/canShare/handler.ts", "../../lib/formulas/decodeURIComponent/handler.ts", "../../lib/formulas/set/handler.ts", "../../lib/formulas/greaterThan/handler.ts", "../../lib/formulas/fromEntries/handler.ts", "../../lib/formulas/filter/handler.ts", "../../lib/formulas/find/handler.ts", "../../lib/formulas/parseURL/handler.ts", "../../lib/formulas/drop/handler.ts", "../../lib/formulas/last/handler.ts", "../../lib/formulas/clamp/handler.ts", "../../lib/formulas/currentURL/handler.ts", "../../lib/formulas/map/handler.ts", "../../lib/formulas/modulo/handler.ts", "../../lib/formulas/getElementById/handler.ts", "../../lib/formulas/replaceAll/handler.ts", "../../lib/formulas/findIndex/handler.ts", "../../lib/formulas/branchName/handler.ts", "../../lib/formulas/decodeBase64/handler.ts", "../../lib/formulas/string/handler.ts", "../../lib/formulas/concatenate/handler.ts", "../../lib/formulas/encodeJSON/handler.ts", "../../lib/formulas/getFromSessionStorage/handler.ts", "../../lib/formulas/equals/handler.ts", "../../lib/formulas/unique/handler.ts", "../../lib/formulas/reverse/handler.ts", "../../lib/formulas/first/handler.ts", "../../lib/formulas/minus/handler.ts", "../../lib/formulas/groupBy/handler.ts", "../../lib/formulas/get/handler.ts", "../../lib/formulas/prepend/handler.ts", "../../lib/formulas/divide/handler.ts", "../../lib/formulas/dateFromString/handler.ts", "../../lib/formulas/typeOf/handler.ts", "../../lib/formulas/takeLast/handler.ts", "../../lib/formulas/absolute/handler.ts", "../../lib/formulas/dropLast/handler.ts", "../../lib/formulas/deleteKey/handler.ts", "../../lib/formulas/timestamp/handler.ts", "../../lib/formulas/entries/handler.ts", "../../lib/formulas/trim/handler.ts", "../../lib/formulas/flatten/handler.ts", "../../lib/formulas/json/handler.ts", "../../lib/formulas/lessOrEqual/handler.ts", "../../lib/formulas/now/handler.ts", "../../lib/formulas/squareRoot/handler.ts", "../../lib/formulas/take/handler.ts", "../../lib/formulas/append/handler.ts", "../../lib/formulas/getFromLocalStorage/handler.ts", "../../lib/formulas/number/handler.ts", "../../lib/formulas/encodeBase64/handler.ts", "../../lib/formulas/join/handler.ts", "../../lib/formulas/range/handler.ts", "../../lib/formulas/max/handler.ts", "../../lib/formulas/lessThan/handler.ts", "../../lib/formulas/shuffle/handler.ts", "../../lib/formulas/lastIndexOf/handler.ts", "../../lib/formulas/power/handler.ts", "../../lib/formulas/roundDown/handler.ts", "../../lib/formulas/every/handler.ts", "../../lib/formulas/keyBy/handler.ts", "../../lib/formulas/parseJSON/handler.ts", "../../lib/formulas/formatDate/handler.ts", "../../lib/formulas/matches/handler.ts", "../../lib/formulas/sum/handler.ts", "../../lib/formulas/startsWith/handler.ts", "../../lib/formulas/dateFromTimestamp/handler.ts", "../../lib/formulas/languages/handler.ts", "../../lib/formulas/split/handler.ts", "../../lib/formulas/size/handler.ts", "../../lib/formulas/isServer/handler.ts", "../../lib/formulas/getCookie/handler.ts", "../../lib/formulas/boolean/handler.ts", "../../lib/formulas/indexOf/handler.ts", "../../lib/formulas/capitalize/handler.ts", "../../lib/formulas/lowercase/handler.ts", "../../lib/formulas/getHttpOnlyCookie/handler.ts", "../../lib/formulas/formatNumber/handler.ts", "../../lib/formulas/add/handler.ts", "../../lib/formulas/greaterOrEqueal/handler.ts", "../../../node_modules/path-to-regexp/src/index.ts", "../src/api/createAPI.ts", "../src/events/handleAction.ts", "../src/api/createAPIv2.ts", "../src/components/renderComponent.ts", "../src/utils/BatchQueue.ts", "../src/components/createNode.ts", "../src/signal/signal.ts", "../src/utils/nodes.ts", "../src/components/createComponent.ts", "../src/context/isContextProvider.ts", "../src/context/subscribeToContext.ts", "../src/debug/logState.ts", "../src/utils/createFormulaCache.ts", "../src/components/createElement.ts", "../src/utils/getDragData.ts", "../src/utils/getElementTagName.ts", "../src/utils/setAttribute.ts", "../src/components/createSlot.ts", "../src/components/createText.ts"],
  "sourcesContent": ["export const isDefined = <T>(value: T | undefined | null): value is T =>\n  value !== null && value !== undefined\n\nexport const isObject = (input: any): input is Record<string, any> =>\n  typeof input === 'object' && input !== null\n\nexport const toBoolean = (value: any) =>\n  value !== false && value !== undefined && value !== null\n", "import type { Formula } from './formula'\n\nexport interface BaseFormula {\n  name: string\n  description?: string\n  arguments: Array<{\n    name: string\n    formula: Formula\n  }>\n  // exported indicates that a formula is exported in a package\n  exported?: boolean\n  variableArguments?: boolean | null\n}\n\nexport interface ToddleFormula extends BaseFormula {\n  formula: Formula\n}\n\n/**\n * The Handler generic is a string server side, but a function client side\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport interface CodeFormula<Handler = string | Function> extends BaseFormula {\n  version?: 2 | never\n  handler: Handler\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport type PluginFormula<Handler = string | Function> =\n  | ToddleFormula\n  | CodeFormula<Handler>\n\nexport const isToddleFormula = <Handler>(\n  formula: PluginFormula<Handler>,\n): formula is ToddleFormula => Object.hasOwn(formula, 'formula')\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport interface GlobalFormulas<Handler = string | Function> {\n  formulas?: Record<string, PluginFormula<Handler>>\n  packages?: Record<\n    string,\n    { formulas?: Record<string, PluginFormula<Handler>> }\n  >\n}\n", "import type { Component, ComponentData } from '../component/component.types'\nimport type {\n  CustomFormulaHandler,\n  FormulaHandler,\n  FormulaLookup,\n  Toddle,\n} from '../types'\nimport { isDefined, toBoolean } from '../utils/util'\nimport { isToddleFormula } from './formulaTypes'\n\n// Define the some objects types as union of ServerSide and ClientSide runtime types as applyFormula is used in both\ndeclare const document: Document | undefined\ntype ShadowRoot = DocumentFragment\n\nexport type PathOperation = {\n  type: 'path'\n  path: string[]\n}\n\ntype FunctionArgument = {\n  name?: string\n  isFunction?: boolean\n  formula: Formula\n}\n\nexport type FunctionOperation = {\n  type: 'function'\n  name: string\n  display_name?: string | null\n  package?: string\n  arguments: FunctionArgument[]\n  variableArguments?: boolean\n}\n\nexport type RecordOperation = {\n  type: 'record'\n  entries: FunctionArgument[]\n}\n\nexport type ObjectOperation = {\n  type: 'object'\n  arguments?: FunctionArgument[]\n}\n\nexport type ArrayOperation = {\n  type: 'array'\n  arguments: Array<{ formula: Formula }>\n}\n\nexport type OrOperation = {\n  type: 'or'\n  arguments: Array<{ formula: Formula }>\n}\n\nexport type AndOperation = {\n  type: 'and'\n  arguments: Array<{ formula: Formula }>\n}\n\nexport type ApplyOperation = {\n  type: 'apply'\n  name: string\n  arguments: FunctionArgument[]\n}\n\nexport type ValueOperation = {\n  type: 'value'\n  value: string | number | boolean | null | object\n}\n\nexport type ValueOperationValue = string | number | boolean | null | object\n\nexport type SwitchOperation = {\n  type: 'switch'\n  cases: Array<{\n    condition: Formula\n    formula: Formula\n  }>\n  default: Formula\n}\n\nexport type Formula =\n  | FunctionOperation\n  | RecordOperation\n  | ObjectOperation\n  | ArrayOperation\n  | PathOperation\n  | SwitchOperation\n  | OrOperation\n  | AndOperation\n  | ValueOperation\n  | ApplyOperation\n\nexport type FormulaContext = {\n  component: Component\n  formulaCache?: Record<\n    string,\n    {\n      get: (data: ComponentData) => any\n      set: (data: ComponentData, result: any) => void\n    }\n  >\n  data: ComponentData\n  root?: Document | ShadowRoot | null\n  package: string | undefined\n  toddle: {\n    getFormula: FormulaLookup\n    getCustomFormula: CustomFormulaHandler\n    errors: Error[]\n  }\n  env: ToddleEnv | undefined\n}\n\nexport type ToddleServerEnv = {\n  branchName: string\n  // isServer will be true for SSR + proxied requests\n  isServer: true\n  request: {\n    headers: Record<string, string>\n    cookies: Record<string, string>\n    url: string\n  }\n  runtime: never\n  logErrors: boolean\n}\n\nexport type ToddleEnv =\n  | ToddleServerEnv\n  | {\n      branchName: string\n      // isServer will be false for client-side\n      isServer: false\n      request: undefined\n      runtime: 'page' | 'custom-element' | 'preview'\n      logErrors: boolean\n    }\n\nexport function isFormula(f: any): f is Formula {\n  return f && typeof f === 'object' && typeof f.type === 'string'\n}\nexport function isFormulaApplyOperation(\n  formula: Formula,\n): formula is ApplyOperation {\n  return formula.type === 'apply'\n}\n\nexport function applyFormula(\n  formula: Formula | string | number | undefined | null | boolean,\n  ctx: FormulaContext,\n): any {\n  if (!isFormula(formula)) {\n    return formula\n  }\n  try {\n    switch (formula.type) {\n      case 'value':\n        return formula.value\n      case 'path': {\n        let input: any = ctx.data\n        for (const key of formula.path) {\n          if (input && typeof input === 'object') {\n            input = input[key]\n          } else {\n            return null\n          }\n        }\n\n        return input\n      }\n      case 'switch': {\n        for (const branch of formula.cases) {\n          if (toBoolean(applyFormula(branch.condition, ctx))) {\n            return applyFormula(branch.formula, ctx)\n          }\n        }\n        return applyFormula(formula.default, ctx)\n      }\n      case 'or': {\n        for (const entry of formula.arguments) {\n          if (toBoolean(applyFormula(entry.formula, ctx))) {\n            return true\n          }\n        }\n        return false\n      }\n      case 'and': {\n        for (const entry of formula.arguments) {\n          if (!toBoolean(applyFormula(entry.formula, ctx))) {\n            return false\n          }\n        }\n        return true\n      }\n      case 'function': {\n        const packageName = formula.package ?? ctx.package\n        const newFunc = (\n          ctx.toddle ??\n          ((globalThis as any).toddle as Toddle<unknown, unknown> | undefined)\n        )?.getCustomFormula(formula.name, packageName)\n        const legacyFunc: FormulaHandler | undefined = (\n          ctx.toddle ?? ((globalThis as any).toddle as Toddle<unknown, unknown>)\n        ).getFormula(formula.name)\n        if (isDefined(newFunc)) {\n          const args = formula.arguments.reduce<Record<string, unknown>>(\n            (args, arg, i) => ({\n              ...args,\n              [arg.name ?? `${i}`]: arg.isFunction\n                ? (Args: any) =>\n                    applyFormula(arg.formula, {\n                      ...ctx,\n                      data: {\n                        ...ctx.data,\n                        Args: ctx.data.Args\n                          ? { ...Args, '@toddle.parent': ctx.data.Args }\n                          : Args,\n                      },\n                    })\n                : applyFormula(arg.formula, ctx),\n            }),\n            {},\n          )\n          try {\n            return isToddleFormula(newFunc)\n              ? applyFormula(newFunc.formula, {\n                  ...ctx,\n                  data: { ...ctx.data, Args: args },\n                })\n              : newFunc.handler(args, {\n                  root: ctx.root ?? document,\n                  env: ctx.env,\n                } as any)\n          } catch (e) {\n            ctx.toddle.errors.push(e as Error)\n            if (ctx.env?.logErrors) {\n              console.error(e)\n            }\n            return null\n          }\n        } else if (typeof legacyFunc === 'function') {\n          const args = (formula.arguments ?? []).map((arg) =>\n            arg.isFunction\n              ? (Args: any) =>\n                  applyFormula(arg.formula, {\n                    ...ctx,\n                    data: {\n                      ...ctx.data,\n                      Args: ctx.data.Args\n                        ? { ...Args, '@toddle.parent': ctx.data.Args }\n                        : Args,\n                    },\n                  })\n              : applyFormula(arg.formula, ctx),\n          )\n          try {\n            return legacyFunc(args, ctx as any)\n          } catch (e) {\n            ctx.toddle.errors.push(e as Error)\n            if (ctx.env?.logErrors) {\n              console.error(e)\n            }\n            return null\n          }\n        }\n        if (ctx.env?.logErrors) {\n          console.error(\n            `Could not find formula ${formula.name} in package ${\n              packageName ?? ''\n            }`,\n            formula,\n          )\n        }\n        return null\n      }\n      case 'object':\n        return Object.fromEntries(\n          formula.arguments?.map((entry) => [\n            entry.name,\n            applyFormula(entry.formula, ctx),\n          ]) ?? [],\n        )\n      case 'record': // object used to be called record, there are still examples in the wild.\n        return Object.fromEntries(\n          formula.entries.map((entry) => [\n            entry.name,\n            applyFormula(entry.formula, ctx),\n          ]),\n        )\n      case 'array':\n        return formula.arguments.map((entry) =>\n          applyFormula(entry.formula, ctx),\n        )\n      case 'apply': {\n        const componentFormula = ctx.component.formulas?.[formula.name]\n        if (!componentFormula) {\n          if (ctx.env?.logErrors) {\n            console.log(\n              'Component does not have a formula with the name ',\n              formula.name,\n            )\n          }\n          return null\n        }\n        const Input = Object.fromEntries(\n          formula.arguments.map((arg) =>\n            arg.isFunction\n              ? [\n                  arg.name,\n                  (Args: any) =>\n                    applyFormula(arg.formula, {\n                      ...ctx,\n                      data: {\n                        ...ctx.data,\n                        Args: ctx.data.Args\n                          ? { ...Args, '@toddle.parent': ctx.data.Args }\n                          : Args,\n                      },\n                    }),\n                ]\n              : [arg.name, applyFormula(arg.formula, ctx)],\n          ),\n        )\n        const data = {\n          ...ctx.data,\n          Args: ctx.data.Args\n            ? { ...Input, '@toddle.parent': ctx.data.Args }\n            : Input,\n        }\n        const cache = ctx.formulaCache?.[formula.name]?.get(data)\n\n        if (cache?.hit) {\n          return cache.data\n        } else {\n          const result = applyFormula(componentFormula.formula, {\n            ...ctx,\n            data,\n          })\n          ctx.formulaCache?.[formula.name]?.set(data, result)\n          return result\n        }\n      }\n\n      default:\n        if (ctx.env?.logErrors) {\n          console.error('Could not recognize formula', formula)\n        }\n    }\n  } catch (e) {\n    if (ctx.env?.logErrors) {\n      console.error(e)\n    }\n    return null\n  }\n}\n", "import { isDefined } from './util'\n\nexport const isObject = (input: any): input is Record<string, any> =>\n  typeof input === 'object' && input !== null\n\nexport const mapObject = <T, T2>(\n  object: Record<string, T>,\n  f: (kv: [string, T]) => [string, T2],\n): Record<string, T2> => Object.fromEntries(Object.entries(object).map(f))\n\nexport const mapValues = <T, T2>(\n  object: Record<string, T>,\n  f: (value: T) => T2,\n): Record<string, T2> => mapObject(object, ([key, value]) => [key, f(value)])\n\nexport const omit = <T = unknown>(collection: T, key: string[]): T => {\n  const [head, ...rest] = key\n\n  const clone: any = Array.isArray(collection)\n    ? [...collection]\n    : isObject(collection)\n      ? { ...collection }\n      : {}\n\n  if (rest.length === 0) {\n    delete clone[head]\n  } else {\n    clone[head] = omit(clone[head], rest)\n  }\n  return clone as T\n}\n\nexport const omitKeys = (object: Record<string, any>, keys: string[]) =>\n  Object.fromEntries(Object.entries(object).filter(([k]) => !keys.includes(k)))\n\nexport const omitPaths = (object: Record<string, any>, keys: string[][]) =>\n  keys.reduce((acc, key) => omit(acc, key), { ...object })\n\nexport const groupBy = <T>(items: T[], f: (t: T) => string) =>\n  items.reduce<Record<string, T[]>>((acc, item) => {\n    const key = f(item)\n    acc[key] = acc[key] ?? []\n    acc[key].push(item)\n    return acc\n  }, {})\n\nexport const filterObject = <T>(\n  object: Record<string, T>,\n  f: (kv: [string, T]) => boolean,\n): Record<string, T> => Object.fromEntries(Object.entries(object).filter(f))\n\nexport function get<T = any>(collection: T, [head, ...rest]: string[]): any {\n  if (rest.length === 0) {\n    return (collection as any)?.[head]\n  }\n  return get((collection as any)?.[head], rest)\n}\n\nexport const set = <T = unknown>(\n  collection: T,\n  key: string[],\n  value: any,\n): T => {\n  const [head, ...rest] = key\n\n  const clone: any = Array.isArray(collection)\n    ? [...collection]\n    : isObject(collection)\n      ? { ...collection }\n      : {}\n\n  clone[head] = rest.length === 0 ? value : set(clone[head], rest, value)\n  return clone as T\n}\n\nexport const sortObjectEntries = <T>(\n  object: Record<string, T>,\n  f: (kv: [string, T]) => string | number | boolean,\n  ascending = true,\n): [string, T][] => easySort(Object.entries(object), f, ascending)\n\nexport const easySort = <T>(\n  collection: T[],\n  f: (item: T) => string | number | boolean,\n  ascending = true,\n) =>\n  [...collection].sort((a, b) => {\n    const keyA = f(a)\n    const keyB = f(b)\n    if (keyA === keyB) {\n      return 0\n    }\n    return (keyA > keyB ? 1 : -1) * (ascending ? 1 : -1)\n  })\n\nexport const deepSortObject = (\n  obj: any,\n): Record<string, any> | Array<any> | undefined | null => {\n  if (!isDefined(obj)) {\n    return obj\n  }\n  if (Array.isArray(obj)) {\n    return obj.map((val) => deepSortObject(val))\n  } else if (typeof obj === 'object' && Object.keys(obj).length > 0) {\n    return [...Object.keys(obj)].sort().reduce<any>((acc, key) => {\n      acc[key] = deepSortObject(obj[key])\n      return acc\n    }, {})\n  }\n  return obj\n}\n", "// Based on https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n// This is a simple hash function for strings. It's not secure, but it's fast.\n// It's not suitable for cryptographic purposes, but it's great for hash tables.\nexport const hash = (data: string, seed = 0) => {\n  let h1 = 0xdeadbeef ^ seed,\n    h2 = 0x41c6ce57 ^ seed\n  for (let i = 0, ch; i < data.length; i++) {\n    ch = data.charCodeAt(i)\n    h1 = Math.imul(h1 ^ ch, 2654435761)\n    h2 = Math.imul(h2 ^ ch, 1597334677)\n  }\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507)\n  h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909)\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507)\n  h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909)\n\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0)\n}\n", "import type { EventModel } from '../component/component.types'\nimport type { Formula } from '../formula/formula'\n\nexport type ComponentAPI = LegacyComponentAPI | ApiRequest\n\nexport interface LegacyComponentAPI {\n  name: string\n  type: 'REST'\n  autoFetch?: Formula | null\n  url?: Formula\n  path?: { formula: Formula }[]\n  proxy?: boolean\n  queryParams?: Record<string, { name: string; formula: Formula }>\n  headers?: Record<string, Formula> | Formula\n  method?: 'GET' | 'POST' | 'DELETE' | 'PUT'\n  body?: Formula\n  auth?: {\n    type: 'Bearer id_token' | 'Bearer access_token'\n  }\n  throttle?: number | null\n  debounce?: number | null\n  onCompleted: EventModel | null\n  onFailed: EventModel | null\n  version?: never\n}\n\nexport interface LegacyApiStatus {\n  data: unknown\n  isLoading: boolean\n  error: unknown\n  response?: never\n}\n\nexport enum ApiMethod {\n  GET = 'GET',\n  POST = 'POST',\n  DELETE = 'DELETE',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  HEAD = 'HEAD',\n  OPTIONS = 'OPTIONS',\n}\n\nexport type RedirectStatusCode = 300 | 301 | 302 | 303 | 304 | 307 | 308\n\nexport interface ApiBase {\n  url?: Formula\n  path?: Record<string, { formula: Formula; index: number }>\n  queryParams?: Record<\n    string,\n    // The enabled formula is used to determine if the query parameter should be included in the request or not\n    { formula: Formula; enabled?: Formula | null }\n  >\n}\n\nexport interface ApiRequest extends ApiBase {\n  version: 2\n  name: string\n  type: 'http' | 'ws' // The structure for web sockets might look different\n  autoFetch?: Formula | null\n  headers?: Record<string, { formula: Formula; enabled?: Formula | null }>\n  method?: ApiMethod\n  body?: Formula\n  // inputs for an API request\n  inputs: Record<string, { formula: Formula | null }>\n  service?: string | null\n  servicePath?: string | null\n  server?: {\n    // We should only accept server side proxy requests if proxy is defined\n    proxy?: {\n      enabled: { formula: Formula }\n    } | null\n    ssr?: {\n      // We should only fetch a request server side during SSR if this is true\n      // it should probably be true by default for autofetch APIs\n      // During SSR we will only fetch autoFetch requests\n      enabled?: { formula: Formula } | null\n    }\n  }\n  client?: {\n    debounce?: { formula: Formula } | null\n    onCompleted?: EventModel | null\n    onFailed?: EventModel | null\n    onMessage?: EventModel | null\n    // parserMode is used to determine how the response should be handled\n    // auto: The response will be handled based on the content type of the response\n    // stream: The response will be handled as a stream\n    parserMode:\n      | 'auto'\n      | 'text'\n      | 'json'\n      | 'event-stream'\n      | 'json-stream'\n      | 'blob'\n  }\n  // Shared logic for client/server \uD83D\uDC47\n  // The user could distinguish using an environment\n  // variable e.g. IS_SERVER when they declare the formula\n\n  // Rules for redirecting the user to a different page\n  // These rules will run both on server+client - mostly used for 401 response -> 302 redirect\n  // We allow multiple rules since it makes it easier to setup multiple conditions/redirect locations\n  redirectRules?: Record<\n    string,\n    {\n      // The formula will receive the response from the server including a status code\n      // A redirect response will be returned if the formula returns a valid url\n      formula: Formula\n      // The status code used in the redirect response. Only relevant server side\n      statusCode?: RedirectStatusCode | null\n      index: number\n    }\n  > | null\n  // Formula for determining whether the response is an error or not. Receives the API response + status code/headers as input\n  // The response is considered an error if the formula returns true\n  // Default behavior is to check if the status code is 400 or higher\n  isError?: { formula: Formula } | null\n  // Formula for determining when the request should time out\n  timeout?: { formula: Formula } | null\n}\n\nexport interface ApiStatus {\n  data: unknown\n  isLoading: boolean\n  error: unknown\n  response?: {\n    status?: number\n    headers?: Record<string, string> | null\n    performance?: ApiPerformance\n    debug?: null | unknown\n  }\n}\n\nexport interface ApiPerformance {\n  requestStart: number | null\n  responseStart: number | null\n  responseEnd: number | null\n}\n\nexport interface ToddleRequestInit extends RequestInit {\n  headers: Headers\n}\n", "import type { ActionModel } from '../component/component.types'\nimport { isDefined } from '../utils/util'\nimport type {\n  Formula,\n  FunctionOperation,\n  PathOperation,\n  ValueOperation,\n} from './formula'\nimport { isFormula } from './formula'\nimport type { GlobalFormulas } from './formulaTypes'\nimport { isToddleFormula } from './formulaTypes'\n\nexport const valueFormula = (\n  value: string | number | boolean | null | object,\n): ValueOperation => ({\n  type: 'value',\n  value,\n})\n\nexport const pathFormula = (path: string[]): PathOperation => ({\n  type: 'path',\n  path,\n})\n\nexport const functionFormula = (\n  name: string,\n  formula?: Omit<Partial<FunctionOperation>, 'type' | 'name'>,\n): FunctionOperation => ({\n  type: 'function',\n  name,\n  package: formula?.package,\n  arguments: formula?.arguments ?? [],\n  variableArguments: formula?.variableArguments,\n})\n\nexport function* getFormulasInFormula<Handler>({\n  formula,\n  globalFormulas,\n  path = [],\n  visitedFormulas = new Set<string>(),\n}: {\n  formula: Formula | undefined | null\n  globalFormulas: GlobalFormulas<Handler>\n  path?: (string | number)[]\n  visitedFormulas?: Set<string>\n}): Generator<[(string | number)[], Formula]> {\n  if (!isDefined(formula)) {\n    return\n  }\n\n  yield [path, formula]\n  switch (formula.type) {\n    case 'path':\n    case 'value':\n      break\n    case 'record':\n      for (const [key, entry] of formula.entries.entries()) {\n        yield* getFormulasInFormula({\n          formula: entry.formula,\n          globalFormulas,\n          path: [...path, 'entries', key, 'formula'],\n          visitedFormulas,\n        })\n      }\n      break\n    case 'function': {\n      const formulaKey = [formula.package, formula.name]\n        .filter(isDefined)\n        .join('/')\n      const shouldVisitFormula = !visitedFormulas.has(formulaKey)\n      visitedFormulas.add(formulaKey)\n      const globalFormula = formula.package\n        ? globalFormulas.packages?.[formula.package]?.formulas?.[formula.name]\n        : globalFormulas.formulas?.[formula.name]\n      for (const [key, arg] of (\n        (formula.arguments as typeof formula.arguments | undefined) ?? []\n      ).entries()) {\n        yield* getFormulasInFormula({\n          formula: arg.formula,\n          globalFormulas,\n          path: [...path, 'arguments', key, 'formula'],\n          visitedFormulas,\n        })\n      }\n      // Lookup the actual function and traverse its potential formula references\n      // if this formula wasn't already visited\n      if (\n        globalFormula &&\n        isToddleFormula(globalFormula) &&\n        shouldVisitFormula\n      ) {\n        yield* getFormulasInFormula({\n          formula: globalFormula.formula,\n          globalFormulas,\n          path: [...path, 'formula'],\n          visitedFormulas,\n        })\n      }\n      break\n    }\n    case 'array':\n    case 'or':\n    case 'and':\n    case 'object':\n      for (const [key, arg] of (\n        (formula.arguments as typeof formula.arguments | undefined) ?? []\n      ).entries()) {\n        yield* getFormulasInFormula({\n          formula: arg.formula,\n          globalFormulas,\n          path: [...path, 'arguments', key, 'formula'],\n          visitedFormulas,\n        })\n      }\n      break\n    case 'apply':\n      for (const [key, arg] of (\n        (formula.arguments as typeof formula.arguments | undefined) ?? []\n      ).entries()) {\n        yield* getFormulasInFormula({\n          formula: arg.formula,\n          globalFormulas,\n          path: [...path, 'arguments', key, 'formula'],\n          visitedFormulas,\n        })\n      }\n      break\n    case 'switch':\n      for (const [key, c] of formula.cases.entries()) {\n        yield* getFormulasInFormula({\n          formula: c.condition,\n          globalFormulas,\n          path: [...path, 'cases', key, 'condition'],\n          visitedFormulas,\n        })\n        yield* getFormulasInFormula({\n          formula: c.formula,\n          globalFormulas,\n          path: [...path, 'cases', key, 'formula'],\n          visitedFormulas,\n        })\n      }\n      yield* getFormulasInFormula({\n        formula: formula.default,\n        globalFormulas,\n        path: [...path, 'default'],\n        visitedFormulas,\n      })\n      break\n  }\n}\nexport function* getFormulasInAction<Handler>({\n  action,\n  globalFormulas,\n  path = [],\n  visitedFormulas = new Set<string>(),\n}: {\n  action: ActionModel | null\n  globalFormulas: GlobalFormulas<Handler>\n  path?: (string | number)[]\n  visitedFormulas?: Set<string>\n}): Generator<[(string | number)[], Formula]> {\n  if (!isDefined(action)) {\n    return\n  }\n\n  switch (action.type) {\n    case 'Fetch':\n      for (const [inputKey, input] of Object.entries(action.inputs ?? {})) {\n        yield* getFormulasInFormula({\n          formula: input.formula,\n          globalFormulas,\n          path: [...path, 'input', inputKey, 'formula'],\n          visitedFormulas,\n        })\n      }\n      for (const [key, a] of Object.entries(action.onSuccess?.actions ?? {})) {\n        yield* getFormulasInAction({\n          action: a,\n          globalFormulas,\n          path: [...path, 'onSuccess', 'actions', key],\n          visitedFormulas,\n        })\n      }\n      for (const [key, a] of Object.entries(action.onError?.actions ?? {})) {\n        yield* getFormulasInAction({\n          action: a,\n          globalFormulas,\n          path: [...path, 'onError', 'actions', key],\n          visitedFormulas,\n        })\n      }\n      for (const [key, a] of Object.entries(action.onMessage?.actions ?? {})) {\n        yield* getFormulasInAction({\n          action: a,\n          globalFormulas,\n          path: [...path, 'onMessage', 'actions', key],\n          visitedFormulas,\n        })\n      }\n      break\n    case 'Custom':\n    case undefined:\n      if (isFormula(action.data)) {\n        yield* getFormulasInFormula({\n          formula: action.data,\n          globalFormulas,\n          path: [...path, 'data'],\n          visitedFormulas,\n        })\n      }\n      for (const [key, a] of Object.entries(action.arguments ?? {})) {\n        yield* getFormulasInFormula({\n          formula: a.formula,\n          globalFormulas,\n          path: [...path, 'arguments', key, 'formula'],\n          visitedFormulas,\n        })\n      }\n\n      for (const [eventKey, event] of Object.entries(action.events ?? {})) {\n        for (const [key, a] of Object.entries(event.actions ?? {})) {\n          yield* getFormulasInAction({\n            action: a,\n            globalFormulas,\n            path: [...path, 'events', eventKey, 'actions', key],\n            visitedFormulas,\n          })\n        }\n      }\n      break\n    case 'SetVariable':\n    case 'SetURLParameter':\n    case 'TriggerEvent':\n      yield* getFormulasInFormula({\n        formula: action.data,\n        globalFormulas,\n        path: [...path, 'data'],\n        visitedFormulas,\n      })\n      break\n    case 'TriggerWorkflow':\n      for (const [key, a] of Object.entries(action.parameters ?? {})) {\n        yield* getFormulasInFormula({\n          formula: a.formula,\n          globalFormulas,\n          path: [...path, 'parameters', key, 'formula'],\n          visitedFormulas,\n        })\n      }\n      break\n    case 'Switch':\n      if (isDefined(action.data) && isFormula(action.data)) {\n        yield* getFormulasInFormula({\n          formula: action.data,\n          globalFormulas,\n          path: [...path, 'data'],\n          visitedFormulas,\n        })\n      }\n      for (const [key, c] of action.cases.entries()) {\n        yield* getFormulasInFormula({\n          formula: c.condition,\n          globalFormulas,\n          path: [...path, 'cases', key, 'condition'],\n          visitedFormulas,\n        })\n        for (const [actionKey, a] of Object.entries(c.actions)) {\n          yield* getFormulasInAction({\n            action: a,\n            globalFormulas,\n            path: [...path, 'cases', key, 'actions', actionKey],\n            visitedFormulas,\n          })\n        }\n      }\n      for (const [actionKey, a] of Object.entries(action.default.actions)) {\n        yield* getFormulasInAction({\n          action: a,\n          globalFormulas,\n          path: [...path, 'default', 'actions', actionKey],\n          visitedFormulas,\n        })\n      }\n      break\n  }\n}\n", "import { isFormula, type Formula } from '../formula/formula'\nimport type { GlobalFormulas } from '../formula/formulaTypes'\nimport {\n  getFormulasInAction,\n  getFormulasInFormula,\n} from '../formula/formulaUtils'\nimport { isDefined } from '../utils/util'\nimport { type LegacyComponentAPI } from './apiTypes'\n\nexport class LegacyToddleApi<Handler> {\n  private api: LegacyComponentAPI\n  private key: string\n  private globalFormulas: GlobalFormulas<Handler>\n  private _apiReferences?: Set<string>\n\n  constructor(\n    api: LegacyComponentAPI,\n    key: string,\n    globalFormulas: GlobalFormulas<Handler>,\n  ) {\n    this.api = api\n    this.key = key\n    this.globalFormulas = globalFormulas\n  }\n\n  get apiReferences(): Set<string> {\n    if (this._apiReferences) {\n      // Only compute apiReferences once\n      return this._apiReferences\n    }\n    const apis = new Set<string>()\n    const visitFormulaReference = (formula?: Formula | null) => {\n      if (!isDefined(formula)) {\n        return\n      }\n      switch (formula.type) {\n        case 'path':\n          if (formula.path[0] === 'Apis') {\n            apis.add(formula.path[1])\n          }\n          break\n        case 'value':\n          break\n        case 'record':\n          formula.entries.forEach((entry) =>\n            visitFormulaReference(entry.formula),\n          )\n          break\n        case 'function':\n        case 'array':\n        case 'or':\n        case 'and':\n        case 'apply':\n        case 'object':\n          formula.arguments?.forEach((arg) =>\n            visitFormulaReference(arg.formula),\n          )\n          break\n        case 'switch':\n          formula.cases.forEach((c) => {\n            visitFormulaReference(c.condition)\n            visitFormulaReference(c.formula)\n          })\n          break\n      }\n    }\n    visitFormulaReference(this.api.autoFetch)\n    visitFormulaReference(this.api.url)\n    Object.values(this.api.path ?? {}).forEach((p) =>\n      visitFormulaReference(p.formula),\n    )\n    Object.values(this.api.queryParams ?? {}).forEach((q) =>\n      visitFormulaReference(q.formula),\n    )\n\n    // this is supporting a few legacy cases where the whole header object was set as a formula. This is no longer possible\n    if (isFormula(this.api.headers)) {\n      visitFormulaReference(this.api.headers)\n    } else {\n      Object.values(this.api.headers ?? {}).forEach((h) => {\n        visitFormulaReference(h)\n      })\n    }\n    visitFormulaReference(this.api.body)\n    this._apiReferences = apis\n    return apis\n  }\n\n  get name() {\n    return this.api.name\n  }\n  get type() {\n    return this.api.type\n  }\n  get autoFetch() {\n    return this.api.autoFetch\n  }\n  get url() {\n    return this.api.url\n  }\n  get path() {\n    return this.api.path\n  }\n  get proxy() {\n    return this.api.proxy\n  }\n  get queryParams() {\n    return this.api.queryParams\n  }\n  get headers() {\n    return this.api.headers\n  }\n  get method() {\n    return this.api.method\n  }\n  get body() {\n    return this.api.body\n  }\n  get auth() {\n    return this.api.auth\n  }\n  get throttle() {\n    return this.api.throttle\n  }\n  get debounce() {\n    return this.api.debounce\n  }\n  get onCompleted() {\n    return this.api.onCompleted\n  }\n  get onFailed() {\n    return this.api.onFailed\n  }\n  *formulasInApi(): Generator<[(string | number)[], Formula]> {\n    const api = this.api\n    const apiKey = this.key\n    yield* getFormulasInFormula({\n      formula: api.autoFetch,\n      globalFormulas: this.globalFormulas,\n      path: ['apis', apiKey, 'autoFetch'],\n    })\n    yield* getFormulasInFormula({\n      formula: api.url,\n      globalFormulas: this.globalFormulas,\n      path: ['apis', apiKey, 'url'],\n    })\n    for (const [pathKey, path] of Object.entries(api.path ?? {})) {\n      yield* getFormulasInFormula({\n        formula: path.formula,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'path', pathKey, 'formula'],\n      })\n    }\n    for (const [queryParamKey, queryParam] of Object.entries(\n      api.queryParams ?? {},\n    )) {\n      yield* getFormulasInFormula({\n        formula: queryParam.formula,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'queryParams', queryParamKey, 'formula'],\n      })\n    }\n\n    // this is supporting a few legacy cases where the whole header object was set as a formula. This is no longer possible\n    if (isFormula(api.headers)) {\n      yield* getFormulasInFormula({\n        formula: api.headers,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'headers'],\n      })\n    } else {\n      for (const [headerKey, header] of Object.entries(api.headers ?? {})) {\n        yield* getFormulasInFormula({\n          formula: header,\n          globalFormulas: this.globalFormulas,\n          path: ['apis', apiKey, 'headers', headerKey],\n        })\n      }\n    }\n\n    yield* getFormulasInFormula({\n      formula: api.body,\n      globalFormulas: this.globalFormulas,\n      path: ['apis', apiKey, 'body'],\n    })\n    for (const [actionKey, action] of Object.entries(\n      api.onCompleted?.actions ?? {},\n    )) {\n      yield* getFormulasInAction({\n        action,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'onCompleted', 'actions', actionKey],\n      })\n    }\n    for (const [actionKey, action] of Object.entries(\n      api.onFailed?.actions ?? {},\n    )) {\n      yield* getFormulasInAction({\n        action,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'onFailed', 'actions', actionKey],\n      })\n    }\n  }\n}\n", "import { isDefined } from '../utils/util'\nimport type { ActionModel } from './component.types'\n\nexport function* getActionsInAction(\n  action: ActionModel | null,\n  path: (string | number)[] = [],\n): Generator<[(string | number)[], ActionModel]> {\n  if (!isDefined(action)) {\n    return\n  }\n\n  yield [path, action]\n  switch (action.type) {\n    case 'SetVariable':\n    case 'SetURLParameter':\n    case 'TriggerEvent':\n    case 'TriggerWorkflow':\n      break\n    case 'Fetch':\n      for (const [key, a] of Object.entries(action.onSuccess?.actions ?? {})) {\n        yield* getActionsInAction(a, [...path, 'onSuccess', 'actions', key])\n      }\n      for (const [key, a] of Object.entries(action.onError?.actions ?? {})) {\n        yield* getActionsInAction(a, [...path, 'onError', 'actions', key])\n      }\n      for (const [key, a] of Object.entries(action.onMessage?.actions ?? {})) {\n        yield* getActionsInAction(a, [...path, 'onMessage', 'actions', key])\n      }\n      break\n    case 'Custom':\n    case undefined:\n      for (const [eventKey, event] of Object.entries(action.events ?? {})) {\n        for (const [key, a] of Object.entries(event?.actions ?? {})) {\n          yield* getActionsInAction(a, [\n            ...path,\n            'events',\n            eventKey,\n            'actions',\n            key,\n          ])\n        }\n      }\n      break\n    case 'Switch':\n      for (const [key, c] of action.cases.entries()) {\n        for (const [actionKey, a] of Object.entries(c?.actions ?? {})) {\n          yield* getActionsInAction(a, [\n            ...path,\n            'cases',\n            key,\n            'actions',\n            actionKey,\n          ])\n        }\n      }\n      for (const [actionKey, a] of Object.entries(action.default.actions)) {\n        yield* getActionsInAction(a, [...path, 'default', 'actions', actionKey])\n      }\n      break\n  }\n}\n", "import { getActionsInAction } from '../component/actionUtils'\nimport type { ActionModel } from '../component/component.types'\nimport { type Formula } from '../formula/formula'\nimport type { GlobalFormulas } from '../formula/formulaTypes'\nimport {\n  getFormulasInAction,\n  getFormulasInFormula,\n} from '../formula/formulaUtils'\nimport { isDefined } from '../utils/util'\nimport type { ApiRequest } from './apiTypes'\n\nexport class ToddleApiV2<Handler> implements ApiRequest {\n  private api: ApiRequest\n  private _apiReferences?: Set<string>\n  private key: string\n  private globalFormulas: GlobalFormulas<Handler>\n\n  constructor(\n    api: ApiRequest,\n    apiKey: string,\n    globalFormulas: GlobalFormulas<Handler>,\n  ) {\n    this.api = api\n    this.key = apiKey\n    this.globalFormulas = globalFormulas\n  }\n\n  get apiReferences(): Set<string> {\n    if (this._apiReferences) {\n      // Only compute apiReferences once\n      return this._apiReferences\n    }\n    const apis = new Set<string>()\n    const visitFormulaReference = (formula?: Formula | null) => {\n      if (!isDefined(formula)) {\n        return\n      }\n      switch (formula.type) {\n        case 'path':\n          if (formula.path[0] === 'Apis') {\n            apis.add(formula.path[1])\n          }\n          break\n        case 'value':\n          break\n        case 'record':\n          formula.entries.forEach((entry) =>\n            visitFormulaReference(entry.formula),\n          )\n          break\n        case 'function':\n        case 'array':\n        case 'or':\n        case 'and':\n        case 'apply':\n        case 'object':\n          formula.arguments?.forEach((arg) =>\n            visitFormulaReference(arg.formula),\n          )\n          break\n        case 'switch':\n          formula.cases.forEach((c) => {\n            visitFormulaReference(c.condition)\n            visitFormulaReference(c.formula)\n          })\n          break\n      }\n    }\n    visitFormulaReference(this.api.autoFetch)\n    visitFormulaReference(this.api.url)\n    Object.values(this.api.path ?? {}).forEach((p) =>\n      visitFormulaReference(p.formula),\n    )\n    Object.values(this.api.headers ?? {}).forEach((h) =>\n      visitFormulaReference(h.formula),\n    )\n    visitFormulaReference(this.api.body)\n    Object.values(this.api.inputs).forEach((arg) =>\n      visitFormulaReference(arg.formula),\n    )\n    Object.values(this.api.queryParams ?? {}).forEach((q) => {\n      visitFormulaReference(q.formula)\n    })\n    visitFormulaReference(this.api.server?.proxy?.enabled?.formula)\n    visitFormulaReference(this.api.server?.ssr?.enabled?.formula)\n    visitFormulaReference(this.api.client?.debounce?.formula)\n    Object.values(this.api.redirectRules ?? {}).forEach((rule) => {\n      visitFormulaReference(rule.formula)\n    })\n    visitFormulaReference(this.api.isError?.formula)\n    visitFormulaReference(this.api.timeout?.formula)\n    // Ensure self references are not included - for instance if an API references its\n    // own response in a redirect rule\n    apis.delete(this.key)\n\n    this._apiReferences = apis\n    return apis\n  }\n\n  get version() {\n    return this.api.version\n  }\n\n  get name() {\n    return this.api.name\n  }\n\n  get type() {\n    return this.api.type\n  }\n\n  get autoFetch() {\n    return this.api.autoFetch\n  }\n\n  get url() {\n    return this.api.url\n  }\n\n  get path() {\n    return this.api.path\n  }\n\n  get headers() {\n    return this.api.headers\n  }\n\n  set headers(headers) {\n    this.api.headers = headers\n  }\n\n  get method() {\n    return this.api.method\n  }\n\n  get body() {\n    return this.api.body\n  }\n\n  get inputs() {\n    return this.api.inputs\n  }\n\n  get queryParams() {\n    return this.api.queryParams\n  }\n\n  get server() {\n    return this.api.server\n  }\n\n  get client() {\n    return this.api.client\n  }\n\n  get redirectRules() {\n    return this.api.redirectRules\n  }\n\n  get isError() {\n    return this.api.isError\n  }\n\n  get timeout() {\n    return this.api.timeout\n  }\n\n  *formulasInApi(): Generator<[(string | number)[], Formula]> {\n    const api = this.api\n    const apiKey = this.key\n    for (const [input, value] of Object.entries(this.api.inputs)) {\n      yield* getFormulasInFormula({\n        formula: value.formula,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'inputs', input, 'formula'],\n      })\n    }\n    yield* getFormulasInFormula({\n      formula: api.autoFetch,\n      globalFormulas: this.globalFormulas,\n      path: ['apis', apiKey, 'autoFetch'],\n    })\n    yield* getFormulasInFormula({\n      formula: api.url,\n      globalFormulas: this.globalFormulas,\n      path: ['apis', apiKey, 'url'],\n    })\n    for (const [pathKey, path] of Object.entries(api.path ?? {})) {\n      yield* getFormulasInFormula({\n        formula: path.formula,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'path', pathKey, 'formula'],\n      })\n    }\n    for (const [queryParamKey, queryParam] of Object.entries(\n      api.queryParams ?? {},\n    )) {\n      yield* getFormulasInFormula({\n        formula: queryParam.formula,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'queryParams', queryParamKey, 'formula'],\n      })\n      yield* getFormulasInFormula({\n        formula: queryParam.enabled,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'queryParams', queryParamKey, 'enabled'],\n      })\n    }\n\n    for (const [headerKey, header] of Object.entries(api.headers ?? {})) {\n      yield* getFormulasInFormula({\n        formula: header.formula,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'headers', headerKey, 'formula'],\n      })\n      yield* getFormulasInFormula({\n        formula: header.enabled,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'headers', headerKey, 'enabled'],\n      })\n    }\n\n    yield* getFormulasInFormula({\n      formula: api.body,\n      globalFormulas: this.globalFormulas,\n      path: ['apis', apiKey, 'body'],\n    })\n    for (const [actionKey, action] of Object.entries(\n      api.client?.onCompleted?.actions ?? {},\n    )) {\n      yield* getFormulasInAction({\n        action,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'client', 'onCompleted', 'actions', actionKey],\n      })\n    }\n    for (const [actionKey, action] of Object.entries(\n      api.client?.onFailed?.actions ?? {},\n    )) {\n      yield* getFormulasInAction({\n        action,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'client', 'onFailed', 'actions', actionKey],\n      })\n    }\n    yield* getFormulasInFormula({\n      formula: api.client?.debounce?.formula,\n      globalFormulas: this.globalFormulas,\n      path: ['apis', apiKey, 'client', 'debounce', 'formula'],\n    })\n    for (const [actionKey, action] of Object.entries(\n      api.client?.onMessage?.actions ?? {},\n    )) {\n      yield* getFormulasInAction({\n        action,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'client', 'onMessage', 'actions', actionKey],\n      })\n    }\n    for (const [rule, value] of Object.entries(api.redirectRules ?? {})) {\n      yield* getFormulasInFormula({\n        formula: value.formula,\n        globalFormulas: this.globalFormulas,\n        path: ['apis', apiKey, 'redirectRules', rule, 'formula'],\n      })\n    }\n    yield* getFormulasInFormula({\n      formula: api.isError?.formula,\n      globalFormulas: this.globalFormulas,\n      path: ['apis', apiKey, 'isError', 'formula'],\n    })\n    yield* getFormulasInFormula({\n      formula: api.timeout?.formula,\n      globalFormulas: this.globalFormulas,\n      path: ['apis', apiKey, 'timeout', 'formula'],\n    })\n    yield* getFormulasInFormula({\n      formula: api.server?.proxy?.enabled.formula,\n      globalFormulas: this.globalFormulas,\n      path: ['apis', apiKey, 'server', 'proxy', 'enabled', 'formula'],\n    })\n    yield* getFormulasInFormula({\n      formula: api.server?.ssr?.enabled?.formula,\n      globalFormulas: this.globalFormulas,\n      path: ['apis', apiKey, 'server', 'ssr', 'enabled', 'formula'],\n    })\n  }\n\n  *actionModelsInApi(): Generator<[(string | number)[], ActionModel]> {\n    for (const [actionKey, action] of Object.entries(\n      this.api.client?.onCompleted?.actions ?? {},\n    )) {\n      yield* getActionsInAction(action, [\n        'apis',\n        this.key,\n        'client',\n        'onCompleted',\n        'actions',\n        actionKey,\n      ])\n    }\n    for (const [actionKey, action] of Object.entries(\n      this.api.client?.onFailed?.actions ?? {},\n    )) {\n      yield* getActionsInAction(action, [\n        'apis',\n        this.key,\n        'client',\n        'onFailed',\n        'actions',\n        actionKey,\n      ])\n    }\n    for (const [actionKey, action] of Object.entries(\n      this.api.client?.onMessage?.actions ?? {},\n    )) {\n      yield* getActionsInAction(action, [\n        'apis',\n        this.key,\n        'client',\n        'onData',\n        'actions',\n        actionKey,\n      ])\n    }\n  }\n}\n", "import type { Formula, FormulaContext } from '../formula/formula'\nimport { applyFormula } from '../formula/formula'\nimport { omitKeys, sortObjectEntries } from '../utils/collections'\nimport { hash } from '../utils/hash'\nimport { isDefined, isObject, toBoolean } from '../utils/util'\nimport type {\n  ApiBase,\n  ApiPerformance,\n  ApiRequest,\n  ComponentAPI,\n  LegacyComponentAPI,\n  ToddleRequestInit,\n} from './apiTypes'\nimport { ApiMethod } from './apiTypes'\nimport { LegacyToddleApi } from './LegacyToddleApi'\nimport { ToddleApiV2 } from './ToddleApiV2'\n\nexport const NON_BODY_RESPONSE_CODES = [101, 204, 205, 304]\n\nexport const isLegacyApi = <Handler>(\n  api: ComponentAPI | LegacyToddleApi<Handler> | ToddleApiV2<Handler>,\n): api is LegacyComponentAPI | LegacyToddleApi<Handler> =>\n  api instanceof LegacyToddleApi ? true : !('version' in api)\n\nexport const createApiRequest = <Handler>({\n  api,\n  formulaContext,\n  baseUrl,\n  defaultHeaders,\n}: {\n  api: ApiRequest | ToddleApiV2<Handler>\n  formulaContext: FormulaContext\n  baseUrl?: string\n  defaultHeaders: Headers | undefined\n}) => {\n  const url = getUrl(api, formulaContext, baseUrl)\n  const requestSettings = getRequestSettings({\n    api,\n    formulaContext,\n    defaultHeaders,\n  })\n\n  return { url, requestSettings }\n}\n\nexport const getUrl = (\n  api: ApiBase,\n  formulaContext: FormulaContext,\n  baseUrl?: string,\n): URL => {\n  let urlPathname = ''\n  let urlQueryParams = new URLSearchParams()\n  let parsedUrl: URL | undefined\n  const url = applyFormula(api.url, formulaContext)\n  if (['string', 'number'].includes(typeof url)) {\n    const urlInput = typeof url === 'number' ? String(url) : url\n    try {\n      // Try to parse the URL to extract potential path and query parameters\n      parsedUrl = new URL(urlInput, baseUrl)\n      urlPathname = parsedUrl.pathname\n      urlQueryParams = parsedUrl.searchParams\n      // eslint-disable-next-line no-empty\n    } catch {}\n  }\n  const pathParams = getRequestPath(api.path, formulaContext)\n  // Combine potential path parameters from the url declaration with the actual path parameters\n  const path = `${urlPathname}${pathParams.length > 0 && !urlPathname.endsWith('/') ? '/' : ''}${pathParams}`\n  // Combine potential query parameters from the url declaration with the actual query parameters\n  const queryParams = new URLSearchParams([\n    ...urlQueryParams,\n    ...getRequestQueryParams(api.queryParams, formulaContext),\n  ])\n  const queryString =\n    [...queryParams.entries()].length > 0 ? `?${queryParams.toString()}` : ''\n  if (parsedUrl) {\n    const combinedUrl = new URL(parsedUrl.origin, baseUrl)\n    combinedUrl.pathname = path\n    combinedUrl.search = queryParams.toString()\n    return combinedUrl\n  } else {\n    return new URL(`${path}${queryString}`, baseUrl)\n  }\n}\n\nconst HttpMethodsWithAllowedBody: ApiMethod[] = [\n  ApiMethod.POST,\n  ApiMethod.DELETE,\n  ApiMethod.PUT,\n  ApiMethod.PATCH,\n  ApiMethod.OPTIONS,\n]\n\nexport const applyAbortSignal = (\n  api: ApiRequest,\n  requestSettings: RequestInit,\n  formulaContext: FormulaContext,\n) => {\n  if (api.timeout) {\n    const timeout = applyFormula(api.timeout.formula, formulaContext)\n    if (typeof timeout === 'number' && !Number.isNaN(timeout) && timeout > 0) {\n      requestSettings.signal = AbortSignal.timeout(timeout)\n    }\n  }\n}\n\nconst getRequestSettings = ({\n  api,\n  formulaContext,\n  defaultHeaders,\n}: {\n  api: ApiRequest\n  formulaContext: FormulaContext\n  defaultHeaders: Headers | undefined\n}): ToddleRequestInit => {\n  const method = Object.values(ApiMethod).includes(api.method as ApiMethod)\n    ? (api.method as ApiMethod)\n    : ApiMethod.GET\n  const headers = getRequestHeaders({\n    apiHeaders: api.headers,\n    formulaContext,\n    defaultHeaders,\n  })\n  const body = getRequestBody({ api, formulaContext, headers, method })\n  if (headers.get('content-type') === 'multipart/form-data') {\n    headers.delete('content-type')\n  }\n\n  const requestSettings: ToddleRequestInit = {\n    method,\n    headers,\n    body,\n  }\n\n  applyAbortSignal(api, requestSettings, formulaContext)\n\n  return requestSettings\n}\n\nexport const getRequestPath = (\n  path: ApiRequest['path'],\n  formulaContext: FormulaContext,\n): string =>\n  sortObjectEntries(path ?? {}, ([_, p]) => p.index)\n    .map(([_, p]) => applyFormula(p.formula, formulaContext))\n    .join('/')\n\nexport const getRequestQueryParams = (\n  params: ApiRequest['queryParams'],\n  formulaContext: FormulaContext,\n): URLSearchParams => {\n  const queryParams = new URLSearchParams()\n  Object.entries(params ?? {}).forEach(([key, param]) => {\n    const enabled = isDefined(param.enabled)\n      ? applyFormula(param.enabled, formulaContext)\n      : true\n    if (!enabled) {\n      return\n    }\n\n    const value = applyFormula(param.formula, formulaContext)\n    if (!isDefined(value)) {\n      // Ignore null/undefined values\n      return\n    }\n    if (Array.isArray(value)) {\n      // Support encoding 1-dimensional arrays\n      value.forEach((v) => queryParams.append(key, String(v)))\n    } else if (isObject(value)) {\n      // Support encoding (nested) objects, but cast any non-object to a String\n      const encodeObject = (obj: Record<string, any>, prefix: string) => {\n        Object.entries(obj).forEach(([key, val]) => {\n          if (!Array.isArray(val) && isObject(val)) {\n            return encodeObject(val, `${prefix}[${key}]`)\n          } else {\n            queryParams.set(`${prefix}[${key}]`, String(val))\n          }\n        })\n      }\n      encodeObject(value, key)\n    } else {\n      queryParams.set(key, String(value))\n    }\n  })\n  return queryParams\n}\n\nexport const getRequestHeaders = ({\n  apiHeaders,\n  formulaContext,\n  defaultHeaders,\n}: {\n  apiHeaders: ApiRequest['headers']\n  formulaContext: FormulaContext\n  defaultHeaders: Headers | undefined\n}) => {\n  const headers = new Headers(defaultHeaders)\n  Object.entries(apiHeaders ?? {}).forEach(([key, param]) => {\n    const enabled = isDefined(param.enabled)\n      ? applyFormula(param.enabled, formulaContext)\n      : true\n    if (enabled) {\n      const value = applyFormula(param.formula, formulaContext)\n      if (isDefined(value)) {\n        try {\n          headers.set(\n            key.trim(),\n            (typeof value === 'string' ? value : String(value)).trim(),\n          )\n          // eslint-disable-next-line no-empty\n        } catch {}\n      }\n    }\n  })\n  return headers\n}\n\nexport const getBaseUrl = ({\n  origin,\n  url,\n}: {\n  origin: string\n  url?: string\n}) =>\n  !isDefined(url) || url === '' || url.startsWith('/') ? origin + url : url\n\n/**\n * Calculate the hash of a Request object based on its properties\n */\nexport const requestHash = (url: URL, request: RequestInit) =>\n  hash(\n    JSON.stringify({\n      url: url.href,\n      method: request.method,\n      headers: omitKeys(\n        Object.fromEntries(Object.entries(request.headers ?? {})),\n        ['host', 'cookie'],\n      ),\n      body: request.body ?? null,\n    }),\n  )\n\nexport const isApiError = ({\n  apiName,\n  response,\n  formulaContext,\n  errorFormula,\n  performance,\n}: {\n  apiName: string\n  response: {\n    ok: boolean\n    status?: number\n    headers?: Record<string, string> | null\n    body: unknown\n  }\n  formulaContext: FormulaContext\n  performance: ApiPerformance\n  errorFormula?: { formula: Formula } | null\n}) => {\n  const errorFormulaRes = errorFormula\n    ? applyFormula(errorFormula.formula, {\n        component: formulaContext.component,\n        package: formulaContext.package,\n        toddle: formulaContext.toddle,\n        data: {\n          Attributes: {},\n          Args: formulaContext.data.Args,\n          Apis: {\n            // The errorFormula will only have access to the data of the current API\n            [apiName]: {\n              isLoading: false,\n              data: response.body,\n              error: null,\n              response: {\n                status: response.status,\n                headers: response.headers,\n                performance,\n              },\n            },\n          },\n        },\n        env: formulaContext.env,\n      })\n    : null\n\n  if (errorFormulaRes === null || errorFormulaRes === undefined) {\n    return !response.ok\n  }\n  return toBoolean(errorFormulaRes)\n}\n\nconst getRequestBody = ({\n  api,\n  formulaContext,\n  headers,\n  method,\n}: {\n  api: ApiRequest\n  formulaContext: FormulaContext\n  headers: Headers\n  method: ApiMethod\n}): FormData | string | undefined => {\n  if (!api.body || !HttpMethodsWithAllowedBody.includes(method)) {\n    return\n  }\n\n  const body = applyFormula(api.body, formulaContext)\n  if (!body) {\n    return\n  }\n  switch (headers.get('content-type')) {\n    case 'application/x-www-form-urlencoded': {\n      if (typeof body === 'object' && body !== null) {\n        return Object.entries(body)\n          .map(([key, value]) => {\n            if (Array.isArray(value)) {\n              return value\n                .map(\n                  (v) => `${encodeURIComponent(key)}=${encodeURIComponent(v)}`,\n                )\n                .join('&')\n            } else {\n              return `${encodeURIComponent(key)}=${encodeURIComponent(\n                String(value),\n              )}`\n            }\n          })\n          .join('&')\n      }\n      return ''\n    }\n    case 'multipart/form-data': {\n      const formData = new FormData()\n      if (typeof body === 'object' && body !== null) {\n        Object.entries(body).forEach(([key, value]) => {\n          formData.set(key, value as string | Blob)\n        })\n      }\n      return formData\n    }\n    case 'text/plain':\n      return String(body)\n    default:\n      return JSON.stringify(body)\n  }\n}\n\nexport const createApiEvent = (\n  eventName: 'message' | 'success' | 'failed',\n  detail: any,\n) => {\n  return new CustomEvent(eventName, {\n    detail,\n  })\n}\n\nconst compareApiDependencies = <Handler>(\n  a: LegacyToddleApi<Handler> | ToddleApiV2<Handler>,\n  b: LegacyToddleApi<Handler> | ToddleApiV2<Handler>,\n) => {\n  const isADependentOnB = a.apiReferences.has(b.name)\n  const isBDependentOnA = b.apiReferences.has(a.name)\n  if (isADependentOnB === isBDependentOnA) {\n    return 0\n  }\n  // 1 means A goes last - hence B is evaluated before A\n  return isADependentOnB ? 1 : -1\n}\n\nexport const sortApiObjects = <Handler>(\n  apis: Array<[string, ComponentAPI]>,\n) => {\n  const apiMap = new Map<\n    string,\n    LegacyToddleApi<Handler> | ToddleApiV2<Handler>\n  >()\n  const getApi = (apiObj: ComponentAPI, key: string) => {\n    let api = apiMap.get(key)\n    if (!api) {\n      api =\n        apiObj.version === 2\n          ? new ToddleApiV2<Handler>(\n              apiObj,\n              key,\n              // global formulas are not required for sorting\n              {\n                formulas: {},\n                packages: {},\n              },\n            )\n          : new LegacyToddleApi<Handler>(\n              apiObj,\n              key,\n              // global formulas are not required for sorting\n              {\n                formulas: {},\n                packages: {},\n              },\n            )\n      apiMap.set(key, api)\n    }\n    return api\n  }\n\n  return [...apis].sort(([aKey, aObj], [bKey, bObj]) => {\n    const a = getApi(aObj, aKey)\n    const b = getApi(bObj, bKey)\n    return compareApiDependencies(a, b)\n  })\n}\n\nexport const sortApiEntries = <Handler>(\n  apis: Array<[string, LegacyToddleApi<Handler> | ToddleApiV2<Handler>]>,\n) => [...apis].sort(([_, a], [__, b]) => compareApiDependencies(a, b))\n", "const iso8601Regex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:.\\d{1,3})?Z$/\n\n/**\n * This function is much slower than JSON parse without reviver and is a major\n * bottleneck in the runtime performance. Especially during startup.\n */\nexport function parseJSONWithDate(input: string) {\n  return JSON.parse(input, (_, value) => {\n    if (\n      typeof value === 'string' &&\n      value.length === 24 &&\n      iso8601Regex.test(value)\n    ) {\n      return new Date(value)\n    }\n    return value\n  })\n}\n", "export const STRING_TEMPLATE = (\n  type: keyof typeof templateTypes,\n  name: string,\n) => {\n  return `{{ ${templateTypes[type]}.${name} }}`\n}\n\nconst templateTypes = {\n  cookies: 'cookies',\n}\n", "'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "/**\n * Checks if a header is a json (content-type) header\n * Also supports edge cases like application/vnd.api+json and application/vnd.contentful.delivery.v1+json\n * See https://jsonapi.org/#mime-types\n */\nexport const isJsonHeader = (header?: string | null) => {\n  if (typeof header !== 'string') {\n    return false\n  }\n  return /^application\\/(json|.*\\+json)/.test(header)\n}\n\nexport const isTextHeader = (header?: string | null) => {\n  if (typeof header !== 'string') {\n    return false\n  }\n  return /^(text\\/|application\\/x-www-form-urlencoded|application\\/(xml|.*\\+xml))/.test(\n    header,\n  )\n}\n\nexport const isEventStreamHeader = (header?: string | null) => {\n  if (typeof header !== 'string') {\n    return false\n  }\n  return /^text\\/event-stream/.test(header)\n}\n\nexport const isJsonStreamHeader = (header?: string | null) => {\n  if (typeof header !== 'string') {\n    return false\n  }\n  return /^(application\\/stream\\+json|application\\/x-ndjson)/.test(header)\n}\n\nexport const isImageHeader = (header?: string | null) => {\n  if (typeof header !== 'string') {\n    return false\n  }\n  return /^image\\//.test(header)\n}\n", "const LOCALHOSTS = ['http://localhost:54404', 'http://preview.localhost:54404']\n\nexport const isLocalhostUrl = (hrefOrOrigin: string) =>\n  LOCALHOSTS.some((host) => hrefOrOrigin.startsWith(host))\n\nexport const isLocalhostHostname = (hostname: string) =>\n  hostname === 'localhost' || hostname === '127.0.0.1'\n\nexport const validateUrl = (url?: string | null, base?: string) => {\n  if (typeof url !== 'string') {\n    return false\n  }\n\n  try {\n    const urlObject = new URL(url, base)\n    // Creating a new URL object will not correctly encode the search params\n    // So we need to iterate over them to make sure they are encoded as that happens when setting them explicitly\n    urlObject.searchParams.forEach((value, key) => {\n      urlObject.searchParams.set(key, value)\n    })\n    return urlObject\n  } catch {\n    return false\n  }\n}\n\nexport const PROXY_URL_HEADER = 'x-toddle-url'\n\nexport const REWRITE_HEADER = 'x-toddle-rewrite'\n", "// cSpell: ignore phash\nconst SEED = 5381\n\n// When we have separate strings it's useful to run a progressive\n// version of djb2 where we pretend that we're still looping over\n// the same string\nconst phash = (h: number, x: string) => {\n  let i = x.length\n\n  while (i) {\n    h = (h * 33) ^ x.charCodeAt(--i)\n  }\n\n  return h\n}\n\n// This is a djb2 hashing function\nconst hash = (x: string) => {\n  return phash(SEED, x)\n}\n\nconst AD_REPLACER_R = /(a)(d)/gi\n\n/* This is the \"capacity\" of our alphabet i.e. 2x26 for all letters plus their capitalized\n * counterparts */\nconst charsLength = 52\n\n/* start at 75 for 'a' until 'z' (25) and then start at 65 for capitalized letters */\nconst getAlphabeticChar = (code: number) =>\n  String.fromCharCode(code + (code > 25 ? 39 : 97))\n\n/* input a number, usually a hash and convert it to base-52 */\nfunction generateAlphabeticName(code: number) {\n  let name = ''\n  let x\n\n  /* get a char and divide by alphabet-length */\n  for (x = Math.abs(code); x > charsLength; x = (x / charsLength) | 0) {\n    name = getAlphabeticChar(x % charsLength) + name\n  }\n\n  return (getAlphabeticChar(x % charsLength) + name).replace(\n    AD_REPLACER_R,\n    '$1-$2',\n  )\n}\n\nexport const getClassName = (object: any) => {\n  return generateAlphabeticName(hash(JSON.stringify(object)))\n}\n\nexport const toValidClassName = (\n  input: string,\n  escapeSpecialCharacters = false,\n) => {\n  // Replace invalid characters with hyphens\n  let className = input\n    // Remove leading and trailing whitespace\n    .trim()\n    // Replace whitespace with hyphens\n    .replace(/\\s+/g, '-')\n\n  if (escapeSpecialCharacters) {\n    className = className.replace(/[^a-zA-Z0-9-_]/g, (match) => `\\\\${match}`)\n  }\n\n  // Ensure the class name doesn't start with a number or special character\n  if (/^[^a-zA-Z]/.test(className)) {\n    className = `_${className}`\n  }\n\n  return className\n}\n", "import { isLegacyApi, sortApiObjects } from '@toddledev/core/dist/api/api'\nimport type {\n  Component,\n  ComponentData,\n} from '@toddledev/core/dist/component/component.types'\nimport type { ToddleEnv } from '@toddledev/core/dist/formula/formula'\nimport { applyFormula } from '@toddledev/core/dist/formula/formula'\nimport type { PluginFormula } from '@toddledev/core/dist/formula/formulaTypes'\nimport type {\n  ActionHandler,\n  ArgumentInputDataFunction,\n  FormulaHandler,\n  FormulaHandlerV2,\n  PluginActionV2,\n  RequireFields,\n  Toddle,\n} from '@toddledev/core/dist/types'\nimport { mapObject } from '@toddledev/core/dist/utils/collections'\nimport { isDefined } from '@toddledev/core/dist/utils/util'\nimport * as libActions from '@toddledev/std-lib/dist/actions'\nimport * as libFormulas from '@toddledev/std-lib/dist/formulas'\nimport fastDeepEqual from 'fast-deep-equal'\nimport { compile, match } from 'path-to-regexp'\nimport { createLegacyAPI } from './api/createAPI'\nimport { createAPI } from './api/createAPIv2'\nimport { renderComponent } from './components/renderComponent'\nimport { isContextProvider } from './context/isContextProvider'\nimport { initLogState, registerComponentToLogState } from './debug/logState'\nimport { signal } from './signal/signal'\nimport type { ComponentContext, ContextApi, LocationSignal } from './types'\n\ninitLogState()\n\nlet env: ToddleEnv\n\nexport const initGlobalObject = (code?: {\n  formulas: Record<string, Record<string, PluginFormula<FormulaHandlerV2>>>\n  actions: Record<string, Record<string, PluginActionV2>>\n}) => {\n  const component = window.__toddle.component\n  const { params, hash, query } = parseUrl(component)\n  env = {\n    isServer: false,\n    branchName: window.__toddle.branch,\n    request: undefined,\n    runtime: 'page',\n    logErrors: true,\n  }\n  window.toddle = (() => {\n    const legacyActions: Record<string, ActionHandler> = {}\n    const legacyFormulas: Record<string, FormulaHandler> = {}\n    const argumentInputDataList: Record<string, ArgumentInputDataFunction> = {}\n    const toddle: Toddle<LocationSignal, never> = {\n      isEqual: fastDeepEqual,\n      errors: [],\n      project: window.__toddle.project,\n      branch: window.__toddle.branch,\n      commit: window.__toddle.commit,\n      components: window.__toddle.components,\n      formulas: code?.formulas ?? {},\n      actions: code?.actions ?? {},\n      registerAction: (name, handler) => {\n        if (legacyActions[name]) {\n          console.error('There already exists an action with the name ', name)\n          return\n        }\n        legacyActions[name] = handler\n      },\n      getAction: (name) => legacyActions[name],\n      registerFormula: (name, handler, getArgumentInputData) => {\n        if (legacyFormulas[name]) {\n          console.error('There already exists a formula with the name ', name)\n          return\n        }\n        legacyFormulas[name] = handler\n        if (getArgumentInputData) {\n          argumentInputDataList[name] = getArgumentInputData\n        }\n      },\n      getFormula: (name) => legacyFormulas[name],\n      getCustomAction: (name, packageName) => {\n        return (\n          toddle.actions[packageName ?? window.__toddle.project]?.[name] ??\n          toddle.actions[window.__toddle.project]?.[name]\n        )\n      },\n      getCustomFormula: (name, packageName) => {\n        return (\n          toddle.formulas[packageName ?? window.__toddle.project]?.[name] ??\n          toddle.formulas[window.__toddle.project]?.[name]\n        )\n      },\n      // eslint-disable-next-line max-params\n      getArgumentInputData: (formulaName, args, argIndex, data) =>\n        argumentInputDataList[formulaName]?.(args, argIndex, data) || data,\n      data: {},\n      locationSignal: signal<any>({\n        route: component.route,\n        page: component.page as string,\n        path: window.location.pathname,\n        params,\n        query,\n        hash,\n      }),\n      eventLog: [],\n      pageState: window.__toddle.pageState,\n      env,\n    }\n    return toddle\n  })()\n\n  // load default formulas and actions\n  Object.entries(libFormulas).forEach(([name, module]) =>\n    window.toddle.registerFormula(\n      '@toddle/' + name,\n      module.default as FormulaHandler,\n      'getArgumentInputData' in module\n        ? module.getArgumentInputData\n        : undefined,\n    ),\n  )\n  Object.entries(libActions).forEach(([name, module]) =>\n    window.toddle.registerAction('@toddle/' + name, module.default),\n  )\n}\n\nexport const createRoot = (domNode: HTMLElement) => {\n  const component = window.__toddle.component\n  if (!domNode) {\n    throw new Error('Cant find root domNode')\n  }\n\n  if (!window.toddle.components) {\n    throw new Error('Missing components')\n  }\n\n  const urlSignal = window.toddle.locationSignal.map(\n    ({ query, page, route, params, hash }) => {\n      let path: string\n      if (route) {\n        const pathSegments: string[] = []\n        for (const segment of route.path) {\n          if (segment.type === 'static') {\n            pathSegments.push(segment.name)\n          } else {\n            const segmentValue = params[segment.name]\n            if (isDefined(segmentValue)) {\n              pathSegments.push(segmentValue)\n            } else {\n              // If a param is missing, we can't build the rest of the path\n              break\n            }\n          }\n        }\n        path = '/' + pathSegments.join('/')\n      } else {\n        path = compile(page as string, { encode: encodeURIComponent })(params)\n      }\n      const hashString = hash === undefined || hash === '' ? '' : '#' + hash\n      const queryString = Object.entries(query)\n        .filter(([_, q]) => q !== null)\n        .map(([key, value]) => {\n          return `${encodeURIComponent(\n            component?.route?.query[key]?.name ?? key,\n          )}=${encodeURIComponent(String(value))}`\n        })\n        .join('&')\n\n      return `${path}${hashString}${\n        queryString.length > 0 ? '?' + queryString : ''\n      }`\n    },\n  )\n\n  window.addEventListener('popstate', () => {\n    if (!component) {\n      return\n    }\n    const { params, hash, query } = parseUrl(component)\n    window.toddle.locationSignal.update(() => {\n      return {\n        route: component?.route,\n        page: component!.page as string,\n        path: window.location.pathname,\n        params,\n        query,\n        hash,\n      }\n    })\n  })\n\n  urlSignal.subscribe((url) => {\n    const [path] = url.split('?')\n    if (path == window.location.pathname) {\n      window.history.replaceState({}, '', url)\n    } else {\n      window.history.pushState({}, '', url)\n    }\n  })\n\n  const routeSignal = window.toddle.locationSignal.map(({ query, params }) => {\n    return { ...query, ...params }\n  })\n\n  const dataSignal = signal<ComponentData>({\n    ...window.toddle.pageState,\n    // Re-initialize variables since some of them might rely on client-side\n    // state (e.g. localStorage, sensors etc.)\n    Variables: mapObject(component.variables, ([name, variable]) => [\n      name,\n      applyFormula(variable.initialValue, {\n        data: window.toddle.pageState,\n        component,\n        formulaCache: {},\n        root: document,\n        package: undefined,\n        toddle: window.toddle,\n        env,\n      }),\n    ]),\n  })\n\n  // Handle dynamic updates of <head> elements (title, og:image etc.)\n  const titleFormula = component.route?.info?.title?.formula\n  const dynamicTitle = titleFormula && titleFormula.type !== 'value'\n  if (dynamicTitle) {\n    dataSignal\n      .map<string | null>(() =>\n        component\n          ? applyFormula(titleFormula, {\n              data: dataSignal.get(),\n              component,\n              root: document,\n              package: undefined,\n              toddle: window.toddle,\n              env,\n            })\n          : null,\n      )\n      .subscribe((newTitle) => {\n        if (isDefined(newTitle) && document.title !== newTitle) {\n          document.title = newTitle\n        }\n      })\n  }\n\n  const descriptionFormula = component.route?.info?.description?.formula\n  const meta = component.route?.info?.meta\n  const dynamicDescription =\n    descriptionFormula && descriptionFormula.type !== 'value'\n  const dynamicMetaFormulas = Object.values(meta ?? {}).some((r) =>\n    Object.values(\n      r.attrs ?? {}, // fallback to make sure we don't crash on legacy values\n    ).some((a) => a.type !== 'value'),\n  )\n  if (dynamicDescription || dynamicMetaFormulas) {\n    const findMetaElement = (name: string) =>\n      [...document.getElementsByTagName('meta')].find(\n        (el) => el.name === name || el.getAttribute('property') === name,\n      ) ?? null\n\n    const updateMetaElement = (\n      entry: { tag: string; attrs: Record<string, string> },\n      id?: string,\n    ) => {\n      let existingElement: HTMLElement | null = null\n      if (isDefined(id)) {\n        existingElement = document.querySelector(`[data-toddle-id=\"${id}\"]`)\n      } else {\n        const identifier = Object.entries(entry.attrs ?? {}).find(([key]) =>\n          ['property', 'name'].includes(key.toLowerCase()),\n        )?.[1]\n        if (isDefined(identifier)) {\n          existingElement = findMetaElement(identifier)\n        }\n      }\n      if (!existingElement) {\n        // If the element didn't already exist, create it\n        existingElement = document.createElement(entry.tag)\n        if (isDefined(id)) {\n          existingElement.setAttribute('data-toddle-id', id)\n        }\n        document.getElementsByTagName('head')[0].appendChild(existingElement)\n      }\n      // Apply all attributes to the element\n      Object.entries(entry.attrs ?? {}).forEach(([key, value]) => {\n        if (!component) {\n          return\n        }\n        existingElement!.setAttribute(key, value)\n      })\n    }\n    if (dynamicDescription) {\n      dataSignal\n        .map<string | null>((data) =>\n          component\n            ? applyFormula(descriptionFormula, {\n                data,\n                component,\n                root: document,\n                package: undefined,\n                toddle: window.toddle,\n                env,\n              })\n            : null,\n        )\n        .subscribe((newDescription) => {\n          if (isDefined(newDescription)) {\n            let descriptionElement = document\n              .getElementsByTagName('meta')\n              .namedItem('description')\n            if (!descriptionElement) {\n              descriptionElement = document.createElement('meta')\n              descriptionElement.name = 'description'\n            }\n            descriptionElement.content = newDescription\n            document\n              .getElementsByTagName('head')[0]\n              .appendChild(descriptionElement)\n            if (\n              meta &&\n              !Object.values(meta).some((m) =>\n                Object.entries(m.attrs ?? {}).some(\n                  ([k, value]) =>\n                    k.toLowerCase() === 'property' &&\n                    value.type === 'value' &&\n                    typeof value.value === 'string' &&\n                    value.value.toLowerCase() === 'og:description',\n                ),\n              )\n            ) {\n              // If there is no formula for the og:description meta tag,\n              // add it with the same value as the description meta tag\n              // this mimics the behavior from our SSR\n              updateMetaElement({\n                tag: 'meta',\n                attrs: {\n                  property: 'og:description',\n                  content: newDescription,\n                },\n              })\n            }\n          }\n        })\n    }\n    if (dynamicMetaFormulas) {\n      Object.entries(meta ?? {})\n        // Filter out meta tags that have no dynamic formulas\n        .filter(([_, entry]) =>\n          // fallback to make sure we don't crash on legacy values.\n          Object.values(entry.attrs ?? {}).some((a) => a.type !== 'value'),\n        )\n        .forEach(([id, entry]) => {\n          dataSignal\n            .map<Record<string, string>>((data) => {\n              // Return the new values for all attributes (we assume they're strings)\n              const values = Object.entries(entry.attrs ?? {}).reduce(\n                (agg, [key, formula]) =>\n                  component\n                    ? {\n                        ...agg,\n                        [key]: applyFormula(formula, {\n                          data,\n                          component,\n                          root: document,\n                          package: undefined,\n                          toddle: window.toddle,\n                          env,\n                        }),\n                      }\n                    : agg,\n                {},\n              )\n              return values\n            })\n            .subscribe((attrs) =>\n              // Update the meta tags with the new values\n              updateMetaElement({ tag: entry.tag, attrs }, id),\n            )\n        })\n    }\n  }\n\n  registerComponentToLogState(component, dataSignal)\n\n  routeSignal.subscribe((route) =>\n    dataSignal.update((data) => ({\n      ...data,\n      'URL parameters': route as Record<string, string>,\n      Attributes: route,\n    })),\n  )\n\n  // Call the abort signal if the component's datasignal is destroyed (component unmounted) to cancel any pending requests\n  const abortController = new AbortController()\n  dataSignal.subscribe(() => {}, {\n    destroy: () =>\n      abortController.abort(`Component ${component.name} unmounted`),\n  })\n\n  const ctx: ComponentContext = {\n    component,\n    components: window.toddle.components,\n    root: document,\n    isRootComponent: true,\n    dataSignal,\n    abortSignal: abortController.signal,\n    children: {},\n    formulaCache: {},\n    providers: {},\n    apis: {},\n    toddle: window.toddle,\n    triggerEvent: (event: string, data: unknown) =>\n      console.info('EVENT FIRED', event, data),\n    package: undefined,\n    env,\n  }\n\n  // Note: this function must run procedurally to ensure apis (which are in correct order) can reference each other\n  sortApiObjects(Object.entries(component.apis)).forEach(([name, api]) => {\n    if (isLegacyApi(api)) {\n      ctx.apis[name] = createLegacyAPI(api, ctx)\n    } else {\n      ctx.apis[name] = createAPI(api, ctx)\n    }\n  })\n  // Trigger actions for all APIs after all of them are created.\n  Object.values(ctx.apis)\n    .filter(\n      (api): api is RequireFields<ContextApi, 'triggerActions'> =>\n        api.triggerActions !== undefined,\n    )\n    .forEach((api) => {\n      api.triggerActions()\n    })\n\n  let providers = ctx.providers\n  if (isContextProvider(component)) {\n    // Subscribe to exposed formulas and update the component's data signal\n    const formulaDataSignals = Object.fromEntries(\n      Object.entries(component.formulas ?? {})\n        .filter(([, formula]) => formula.exposeInContext)\n        .map(([name, formula]) => [\n          name,\n          dataSignal.map((data) =>\n            applyFormula(formula.formula, {\n              data,\n              component,\n              formulaCache: ctx.formulaCache,\n              root: ctx.root,\n              package: ctx.package,\n              toddle: window.toddle,\n              env,\n            }),\n          ),\n        ]),\n    )\n\n    providers = {\n      ...providers,\n      [component.name]: {\n        component,\n        formulaDataSignals,\n        ctx,\n      },\n    }\n  }\n\n  const elements = renderComponent({\n    ...ctx,\n    providers,\n    path: '0',\n    package: undefined,\n    onEvent: ctx.triggerEvent,\n    parentElement: domNode,\n    instance: {},\n  })\n  domNode.innerText = ''\n  elements.forEach((elem) => {\n    domNode.appendChild(elem)\n  })\n  window.__toddle.isPageLoaded = true\n}\n\nfunction parseUrl(component: Component) {\n  const path = window.location.pathname.split('/').slice(1)\n  let params: Record<string, string | null> = {}\n  if (component.route) {\n    component.route.path.forEach((segment, i) => {\n      if (segment.type === 'param') {\n        if (isDefined(path[i]) && path[i] !== '') {\n          params[segment.name] = decodeURIComponent(path[i])\n        } else {\n          params[segment.name] = null\n        }\n      } else {\n        params[segment.name] = segment.name\n      }\n    })\n  } else {\n    const urlPattern = match<Record<string, string>>(component.page ?? '', {\n      decode: decodeURIComponent,\n    })\n    const res = urlPattern(window.location.pathname) || {\n      params: {},\n    }\n    params = res.params\n  }\n\n  const [hash] = window.location.hash.split('?')\n  const query = parseQuery(window.location.search) as Record<string, string>\n  // Explicitly set all query params to null by default\n  // to avoid undefined values in the runtime\n  const defaultQueryParams = Object.keys(component.route?.query ?? {}).reduce<\n    Record<string, null>\n  >((params, key) => ({ ...params, [key]: null }), {})\n  return {\n    params,\n    hash: hash?.slice(1),\n    query: { ...defaultQueryParams, ...query },\n  }\n}\n\nconst parseQuery = (queryString: string) =>\n  Object.fromEntries(\n    queryString\n      .replace('?', '')\n      .split('&')\n      .filter((pair) => pair !== '')\n      .map((pair: string) => {\n        return pair.split('=').map(decodeURIComponent)\n      }),\n  )\n", "import * as sleep from \"./actions/sleep/handler\"\nimport * as deleteFromLocalStorage from \"./actions/deleteFromLocalStorage/handler\"\nimport * as share from \"./actions/share/handler\"\nimport * as saveToSessionStorage from \"./actions/saveToSessionStorage/handler\"\nimport * as preventDefault from \"./actions/preventDefault/handler\"\nimport * as interval from \"./actions/interval/handler\"\nimport * as clearLocalStorage from \"./actions/clearLocalStorage/handler\"\nimport * as deleteFromSessionStorage from \"./actions/deleteFromSessionStorage/handler\"\nimport * as logToConsole from \"./actions/logToConsole/handler\"\nimport * as copyToClipboard from \"./actions/copyToClipboard/handler\"\nimport * as setSessionCookies from \"./actions/setSessionCookies/handler\"\nimport * as saveToLocalStorage from \"./actions/saveToLocalStorage/handler\"\nimport * as focus from \"./actions/focus/handler\"\nimport * as clearSessionStorage from \"./actions/clearSessionStorage/handler\"\nimport * as gotToURL from \"./actions/gotToURL/handler\"\nimport * as stopPropagation from \"./actions/stopPropagation/handler\"\n\nexport {\n  sleep,\n  deleteFromLocalStorage,\n  share,\n  saveToSessionStorage,\n  preventDefault,\n  interval,\n  clearLocalStorage,\n  deleteFromSessionStorage,\n  logToConsole,\n  copyToClipboard,\n  setSessionCookies,\n  saveToLocalStorage,\n  focus,\n  clearSessionStorage,\n  gotToURL,\n  stopPropagation\n}\n  ", "import type { ActionHandler } from '@toddledev/core/dist/types'\nimport { isDefined } from '@toddledev/core/dist/utils/util'\n\nconst handler: ActionHandler = ([delay], ctx) => {\n  // We'll cast delay in case it's passed as a string\n  const delayNumber = Number(delay)\n  if (!isDefined(delay) || Number.isNaN(delay)) {\n    throw new Error('Invalid delay value')\n  }\n  const timeout = setTimeout(\n    () => ctx.triggerActionEvent('tick', null),\n    delayNumber,\n  )\n  ctx.abortSignal.addEventListener('abort', () => {\n    clearTimeout(timeout)\n  })\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = async function ([key]) {\n  if (typeof key !== 'string' || key.length === 0) {\n    throw new Error(`Invalid key: ${key}`)\n  }\n  window.localStorage.removeItem(key)\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\nimport { isDefined } from '@toddledev/core/dist/utils/util'\n\nconst handler: ActionHandler = ([url, title, text]) => {\n  const validInput = (value: any): value is string =>\n    isDefined(value) && typeof value === 'string'\n  if (!validInput(url) && !validInput(title) && !validInput(text)) {\n    throw new Error(`Either url, text or title must be provided`)\n  }\n  const data: ShareData = {}\n  if (validInput(title)) {\n    data.title = title\n  }\n  if (validInput(text)) {\n    data.text = text\n  }\n  if (validInput(url)) {\n    data.url = url\n  }\n  // Later we can add support for data.files as well\n  if (isDefined(navigator.share) && navigator.canShare(data)) {\n    return navigator.share(data)\n  }\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = async function ([key, value]) {\n  if (typeof key !== 'string' || key.length === 0) {\n    throw new Error(`Invalid key: ${key}`)\n  }\n  window.sessionStorage.setItem(key, JSON.stringify(value))\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = (_, _ctx, event) => {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  event?.preventDefault?.()\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\nimport { isDefined } from '@toddledev/core/dist/utils/util'\n\nconst handler: ActionHandler = ([delay], ctx) => {\n  // We'll cast delay in case it's passed as a string\n  const delayNumber = Number(delay)\n  if (!isDefined(delay) || Number.isNaN(delay)) {\n    throw new Error('Invalid delay value')\n  }\n  const interval = setInterval(\n    () => ctx.triggerActionEvent('tick', null),\n    delayNumber,\n  )\n  ctx.abortSignal.addEventListener('abort', () => {\n    clearInterval(interval)\n  })\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = async function () {\n  window.localStorage.clear()\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = async function ([key]) {\n  if (typeof key !== 'string' || key.length === 0) {\n    throw new Error(`Invalid key: ${key}`)\n  }\n  window.sessionStorage.removeItem(key)\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = ([label, data]: unknown[]) => {\n  console.log(label, data)\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = ([value]) => {\n  if (typeof value !== 'string') {\n    throw new Error(`Input value must be a string`)\n  }\n  return navigator.clipboard.writeText(value)\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = async function ([access_token, ttl], ctx) {\n  const query = [\n    typeof access_token === 'string'\n      ? `name=access_token&value=${encodeURIComponent(access_token)}`\n      : undefined,\n    isNaN(Number(ttl)) ? undefined : `ttl=${ttl}`,\n  ]\n    .filter((a) => a)\n    .join('&')\n  const res = await fetch(`/.toddle/cookies/set-session-cookie?${query}`)\n  if (res.ok) {\n    ctx.triggerActionEvent('Success', undefined)\n  } else {\n    ctx.triggerActionEvent('Error', new Error(await res.text()))\n  }\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = async function ([key, value]) {\n  if (typeof key !== 'string' || key.length === 0) {\n    throw new Error(`Invalid key: ${key}`)\n  }\n  window.localStorage.setItem(key, JSON.stringify(value))\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = ([elem]) => {\n  if (elem instanceof HTMLElement) {\n    elem.focus()\n  }\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = async function () {\n  window.sessionStorage.clear()\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = ([url], ctx) => {\n  if (typeof url === 'string') {\n    if (ctx.env.runtime === 'preview') {\n      // Attempt to notify the parent about the failed navigation attempt\n      window.parent?.postMessage({ type: 'blockedNavigation', url }, '*')\n    } else {\n      window.location.href = url\n    }\n  }\n}\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\n\nconst handler: ActionHandler = (_, _ctx, event) => {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  event?.stopPropagation?.()\n}\n\nexport default handler\n", "import * as notEqual from \"./formulas/notEqual/handler\"\nimport * as findLast from \"./formulas/findLast/handler\"\nimport * as userAgent from \"./formulas/userAgent/handler\"\nimport * as round from \"./formulas/round/handler\"\nimport * as defaultTo from \"./formulas/defaultTo/handler\"\nimport * as multiply from \"./formulas/multiply/handler\"\nimport * as randomNumber from \"./formulas/randomNumber/handler\"\nimport * as reduce from \"./formulas/reduce/handler\"\nimport * as includes from \"./formulas/includes/handler\"\nimport * as min from \"./formulas/min/handler\"\nimport * as uppercase from \"./formulas/uppercase/handler\"\nimport * as encodeURIComponent from \"./formulas/encodeURIComponent/handler\"\nimport * as sort_by from \"./formulas/sort_by/handler\"\nimport * as some from \"./formulas/some/handler\"\nimport * as roundUp from \"./formulas/roundUp/handler\"\nimport * as not from \"./formulas/not/handler\"\nimport * as canShare from \"./formulas/canShare/handler\"\nimport * as decodeURIComponent from \"./formulas/decodeURIComponent/handler\"\nimport * as set from \"./formulas/set/handler\"\nimport * as greaterThan from \"./formulas/greaterThan/handler\"\nimport * as fromEntries from \"./formulas/fromEntries/handler\"\nimport * as filter from \"./formulas/filter/handler\"\nimport * as find from \"./formulas/find/handler\"\nimport * as parseURL from \"./formulas/parseURL/handler\"\nimport * as drop from \"./formulas/drop/handler\"\nimport * as last from \"./formulas/last/handler\"\nimport * as clamp from \"./formulas/clamp/handler\"\nimport * as currentURL from \"./formulas/currentURL/handler\"\nimport * as map from \"./formulas/map/handler\"\nimport * as modulo from \"./formulas/modulo/handler\"\nimport * as getElementById from \"./formulas/getElementById/handler\"\nimport * as replaceAll from \"./formulas/replaceAll/handler\"\nimport * as findIndex from \"./formulas/findIndex/handler\"\nimport * as branchName from \"./formulas/branchName/handler\"\nimport * as decodeBase64 from \"./formulas/decodeBase64/handler\"\nimport * as string from \"./formulas/string/handler\"\nimport * as concatenate from \"./formulas/concatenate/handler\"\nimport * as encodeJSON from \"./formulas/encodeJSON/handler\"\nimport * as getFromSessionStorage from \"./formulas/getFromSessionStorage/handler\"\nimport * as equals from \"./formulas/equals/handler\"\nimport * as unique from \"./formulas/unique/handler\"\nimport * as reverse from \"./formulas/reverse/handler\"\nimport * as first from \"./formulas/first/handler\"\nimport * as minus from \"./formulas/minus/handler\"\nimport * as groupBy from \"./formulas/groupBy/handler\"\nimport * as get from \"./formulas/get/handler\"\nimport * as prepend from \"./formulas/prepend/handler\"\nimport * as divide from \"./formulas/divide/handler\"\nimport * as dateFromString from \"./formulas/dateFromString/handler\"\nimport * as typeOf from \"./formulas/typeOf/handler\"\nimport * as takeLast from \"./formulas/takeLast/handler\"\nimport * as absolute from \"./formulas/absolute/handler\"\nimport * as dropLast from \"./formulas/dropLast/handler\"\nimport * as deleteKey from \"./formulas/deleteKey/handler\"\nimport * as timestamp from \"./formulas/timestamp/handler\"\nimport * as entries from \"./formulas/entries/handler\"\nimport * as trim from \"./formulas/trim/handler\"\nimport * as flatten from \"./formulas/flatten/handler\"\nimport * as json from \"./formulas/json/handler\"\nimport * as lessOrEqual from \"./formulas/lessOrEqual/handler\"\nimport * as now from \"./formulas/now/handler\"\nimport * as squareRoot from \"./formulas/squareRoot/handler\"\nimport * as take from \"./formulas/take/handler\"\nimport * as append from \"./formulas/append/handler\"\nimport * as getFromLocalStorage from \"./formulas/getFromLocalStorage/handler\"\nimport * as number from \"./formulas/number/handler\"\nimport * as encodeBase64 from \"./formulas/encodeBase64/handler\"\nimport * as join from \"./formulas/join/handler\"\nimport * as range from \"./formulas/range/handler\"\nimport * as max from \"./formulas/max/handler\"\nimport * as lessThan from \"./formulas/lessThan/handler\"\nimport * as shuffle from \"./formulas/shuffle/handler\"\nimport * as lastIndexOf from \"./formulas/lastIndexOf/handler\"\nimport * as power from \"./formulas/power/handler\"\nimport * as roundDown from \"./formulas/roundDown/handler\"\nimport * as every from \"./formulas/every/handler\"\nimport * as keyBy from \"./formulas/keyBy/handler\"\nimport * as parseJSON from \"./formulas/parseJSON/handler\"\nimport * as formatDate from \"./formulas/formatDate/handler\"\nimport * as matches from \"./formulas/matches/handler\"\nimport * as sum from \"./formulas/sum/handler\"\nimport * as startsWith from \"./formulas/startsWith/handler\"\nimport * as dateFromTimestamp from \"./formulas/dateFromTimestamp/handler\"\nimport * as languages from \"./formulas/languages/handler\"\nimport * as split from \"./formulas/split/handler\"\nimport * as size from \"./formulas/size/handler\"\nimport * as isServer from \"./formulas/isServer/handler\"\nimport * as getCookie from \"./formulas/getCookie/handler\"\nimport * as boolean from \"./formulas/boolean/handler\"\nimport * as indexOf from \"./formulas/indexOf/handler\"\nimport * as capitalize from \"./formulas/capitalize/handler\"\nimport * as lowercase from \"./formulas/lowercase/handler\"\nimport * as getHttpOnlyCookie from \"./formulas/getHttpOnlyCookie/handler\"\nimport * as formatNumber from \"./formulas/formatNumber/handler\"\nimport * as add from \"./formulas/add/handler\"\nimport * as greaterOrEqueal from \"./formulas/greaterOrEqueal/handler\"\n\nexport {\n  notEqual,\n  findLast,\n  userAgent,\n  round,\n  defaultTo,\n  multiply,\n  randomNumber,\n  reduce,\n  includes,\n  min,\n  uppercase,\n  encodeURIComponent,\n  sort_by,\n  some,\n  roundUp,\n  not,\n  canShare,\n  decodeURIComponent,\n  set,\n  greaterThan,\n  fromEntries,\n  filter,\n  find,\n  parseURL,\n  drop,\n  last,\n  clamp,\n  currentURL,\n  map,\n  modulo,\n  getElementById,\n  replaceAll,\n  findIndex,\n  branchName,\n  decodeBase64,\n  string,\n  concatenate,\n  encodeJSON,\n  getFromSessionStorage,\n  equals,\n  unique,\n  reverse,\n  first,\n  minus,\n  groupBy,\n  get,\n  prepend,\n  divide,\n  dateFromString,\n  typeOf,\n  takeLast,\n  absolute,\n  dropLast,\n  deleteKey,\n  timestamp,\n  entries,\n  trim,\n  flatten,\n  json,\n  lessOrEqual,\n  now,\n  squareRoot,\n  take,\n  append,\n  getFromLocalStorage,\n  number,\n  encodeBase64,\n  join,\n  range,\n  max,\n  lessThan,\n  shuffle,\n  lastIndexOf,\n  power,\n  roundDown,\n  every,\n  keyBy,\n  parseJSON,\n  formatDate,\n  matches,\n  sum,\n  startsWith,\n  dateFromTimestamp,\n  languages,\n  split,\n  size,\n  isServer,\n  getCookie,\n  boolean,\n  indexOf,\n  capitalize,\n  lowercase,\n  getHttpOnlyCookie,\n  formatNumber,\n  add,\n  greaterOrEqueal\n}\n  ", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nconst handler: FormulaHandler<boolean> = ([a, b]) => {\n  return !(globalThis as any).toddle.isEqual(a, b)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nexport const handler: FormulaHandler<unknown> = ([items, fx]) => {\n  if (typeof fx !== 'function') {\n    // throw new Error(\"Argument 'Formula' must be of type formula\")\n    return null\n  }\n  if (Array.isArray(items)) {\n    return items.findLast((item, index) => fx({ item, index }))\n  }\n  if (items && typeof items === 'object') {\n    return Object.entries(items).findLast(([key, value]) =>\n      fx({ key, value }),\n    )?.[1]\n  }\n  // throw new Error(\"Argument 'Array' must be of type object or array\")\n  return null\n}\n\nexport default handler\n\nexport const getArgumentInputData = (\n  [items]: unknown[],\n  argIndex: number,\n  input: any,\n) => {\n  if (argIndex === 0) {\n    return input\n  }\n\n  if (Array.isArray(items)) {\n    return { ...input, Args: { item: items[0], index: 0 } }\n  }\n  if (items && typeof items === 'object') {\n    const [first] = Object.entries(items)\n    if (first) {\n      return { ...input, Args: { key: first[0], value: first[1] } }\n    }\n  }\n  return input\n}\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = (_, { env }) => {\n  if (!env.isServer) {\n    return window.navigator.userAgent\n  } else {\n    return env.request?.headers['user-agent'] ?? null\n  }\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([input, decimals]) => {\n  if (typeof input !== 'number') {\n    // throw new Error(\"Argument 'Input' must be of type number\")\n    return null\n  }\n  if (typeof decimals !== 'number') {\n    // throw new Error(\"Argument 'Decimals' must be of type number\")\n    return null\n  }\n\n  const multiplier = Math.max(1, Math.pow(10, decimals))\n  return Math.round(input * multiplier) / multiplier\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nimport { toBoolean } from '@toddledev/core/dist/utils/util'\n\nconst handler: FormulaHandler<unknown> = (values) => {\n  for (const value of values) {\n    if (toBoolean(value)) {\n      return value\n    }\n  }\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = (numbers) => {\n  if (numbers.some((n) => isNaN(Number(n)))) {\n    return null\n  }\n  return (numbers as number[]).reduce<number>(\n    (product, num) => product * num,\n    1,\n  )\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = () => {\n  return Math.random()\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<unknown> = ([items, fx, init]) => {\n  if (typeof fx !== 'function') {\n    // throw new Error(\"Argument 'Formula' must be of type formula\")\n    return null\n  }\n  if (Array.isArray(items)) {\n    return items.reduce(\n      (result, item, index) => fx({ result, item, index }),\n      init,\n    )\n  }\n  if (items && typeof items === 'object') {\n    return Object.entries(items).reduce(\n      (result, [key, value]) => fx({ result, key, value }),\n      init,\n    )\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or object\")\n  return null\n}\nexport default handler\n\nexport const getArgumentInputData = (\n  [items, _, result]: unknown[],\n  argIndex: number,\n  input: any,\n) => {\n  if (argIndex !== 1) {\n    return input\n  }\n  if (Array.isArray(items)) {\n    return {\n      ...input,\n      Args: {\n        item: items[0],\n        index: 0,\n        result,\n      },\n    }\n  }\n  if (items && typeof items === 'object') {\n    const [first] = Object.entries(items)\n    if (first) {\n      return {\n        ...input,\n        Args: {\n          key: first[0],\n          value: first[1],\n          result,\n        },\n      }\n    }\n  }\n  return input\n}\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nconst handler: FormulaHandler<boolean> = ([collection, item]) => {\n  if (typeof collection === 'string' && typeof item === 'string') {\n    return collection.includes(item)\n  }\n  if (Array.isArray(collection)) {\n    return collection.some((collectionItem) =>\n      (globalThis as any).toddle.isEqual(collectionItem, item),\n    )\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or string\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = (args) => {\n  return Math.min(...args.map(Number))\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([input]) => {\n  if (typeof input !== 'string') {\n    // throw new Error(\"Argument 'String' must be of type string\")\n    return null\n  }\n  return input.toLocaleUpperCase()\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([URIComponent]) => {\n  if (typeof URIComponent !== 'string') {\n    // throw new Error(\"Argument 'String' must be of type string\")\n    return null\n  }\n  return encodeURIComponent(URIComponent)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown>> = ([\n  array,\n  formula,\n  ascending,\n]) => {\n  if (!Array.isArray(array)) {\n    // throw new Error(\"Argument 'Array' must be an array\")\n    return null\n  }\n  if (typeof formula !== 'function') {\n    // throw new Error(\"Argument 'Formula' must be a formula\")\n    return null\n  }\n  if (typeof ascending !== 'boolean') {\n    // throw new Error(\"Argument 'Ascending?' must be a boolean\")\n    return null\n  }\n\n  const ascendingModifier = ascending ? 1 : -1\n  return [...array].sort((a: any, b: any) => {\n    const keyA = formula({ item: a })\n    const keyB = formula({ item: b })\n    if (Array.isArray(keyA) && Array.isArray(keyB)) {\n      for (const i in keyA) {\n        if (keyA[i] === keyB[i]) {\n          continue\n        }\n        return (keyA[i] > keyB[i] ? 1 : -1) * ascendingModifier\n      }\n      return 0\n    }\n\n    if (keyA === keyB) {\n      return 0\n    }\n    return (keyA > keyB ? 1 : -1) * ascendingModifier\n  })\n}\n\nexport default handler\n\nexport const getArgumentInputData = (\n  [items]: unknown[],\n  argIndex: number,\n  input: any,\n) => {\n  if (argIndex === 1 && Array.isArray(items)) {\n    return { ...input, Args: { item: items[0] } }\n  }\n\n  return input\n}\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nexport const handler: FormulaHandler<boolean> = ([items, fx]: unknown[]) => {\n  if (typeof fx !== 'function') {\n    // throw new Error(\"Argument 'Formula' must be of type formula\")\n    return null\n  }\n  if (Array.isArray(items)) {\n    return items.some((item, index) => fx({ item, index }))\n  }\n  if (items && typeof items === 'object') {\n    return Object.entries(items).some(([key, value]) => fx({ key, value }))\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or object\")\n  return null\n}\n\nexport default handler\n\nexport const getArgumentInputData = (\n  [items]: unknown[],\n  argIndex: number,\n  input: any,\n) => {\n  if (argIndex === 0) {\n    return input\n  }\n\n  if (Array.isArray(items)) {\n    return { ...input, Args: { item: items[0], index: 0 } }\n  }\n  if (items && typeof items === 'object') {\n    const [first] = Object.entries(items)\n    if (first) {\n      return { ...input, Args: { key: first[0], value: first[1] } }\n    }\n  }\n  return input\n}\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([input, decimals]) => {\n  if (typeof input !== 'number') {\n    // throw new Error(\"Argument 'Input' must be of type number\")\n    return null\n  }\n  if (typeof decimals !== 'number') {\n    // throw new Error(\"Argument 'Decimals' must be of type number\")\n    return null\n  }\n\n  const multiplier = Math.max(1, Math.pow(10, decimals))\n  return Math.ceil(input * multiplier) / multiplier\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nimport { toBoolean } from '@toddledev/core/dist/utils/util'\n\nconst handler: FormulaHandler<boolean> = ([a]) => !toBoolean(a)\n\nexport default handler\n", "import type { ActionHandler } from '@toddledev/core/dist/types'\nimport { isDefined } from '@toddledev/core/dist/utils/util'\n\nconst handler: ActionHandler = ([url, title, text]) => {\n  if (!isDefined(navigator.canShare)) {\n    return false\n  }\n  const validInput = (value: any): value is string =>\n    isDefined(value) && typeof value === 'string'\n  if (!validInput(url) && !validInput(title) && !validInput(text)) {\n    return false\n  }\n  const data: ShareData = {}\n  if (validInput(title)) {\n    data.title = title\n  }\n  if (validInput(text)) {\n    data.text = text\n  }\n  if (validInput(url)) {\n    data.url = url\n  }\n  // Later we can add support for data.files as well\n  return navigator.canShare(data)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([URIComponent]) => {\n  if (typeof URIComponent !== 'string') {\n    // throw new Error(\"Argument 'String' must be of type string\")\n    return null\n  }\n  return decodeURIComponent(URIComponent)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nimport { isObject } from '@toddledev/core/dist/utils/util'\n\nconst handler: FormulaHandler<Array<unknown> | Record<string, unknown>> = (\n  [collection, key, value],\n  ctx,\n): any => {\n  if (\n    typeof key !== 'string' &&\n    typeof key !== 'number' &&\n    !Array.isArray(key)\n  ) {\n    // throw new Error(\"Argument 'Path' must be of type array, string or number\")\n    return null\n  }\n  const [head, ...rest] = Array.isArray(key) ? key : [key]\n  if (isObject(collection)) {\n    const clone: Record<string, any> = Array.isArray(collection)\n      ? [...collection]\n      : { ...collection }\n    clone[head] =\n      rest.length === 0 ? value : handler([clone[head], rest, value], ctx)\n    return clone\n  }\n  // throw new Error(\"Argument 'Object' must be of type object or array\")\n  return null\n}\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<boolean> = ([first, second]: any[]) => {\n  return first > second\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Record<string, unknown>> = ([list]) => {\n  if (Array.isArray(list)) {\n    const object: Record<string, any> = {}\n    for (const { key, value } of list) {\n      object[key] = value\n    }\n    return object\n  }\n  // throw new Error(\"Argument 'Array' must be of type array\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nexport const handler: FormulaHandler<\n  Array<unknown> | Record<string, unknown>\n> = ([items, func]) => {\n  if (typeof func !== 'function') {\n    // throw new Error(\"Argument 'Formula' must be of type Formula\")\n    return null\n  }\n\n  if (Array.isArray(items)) {\n    return items.filter((item, index) => func({ item, index }))\n  }\n  if (items && typeof items === 'object') {\n    return Object.fromEntries(\n      Object.entries(items).filter(([key, value]) => func({ key, value })),\n    )\n  }\n  if (Array.isArray(items)) {\n    return items.filter((item, index) => func({ item, index }))\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or object\")\n  return null\n}\n\nexport default handler\n\nexport const getArgumentInputData = (\n  [items]: unknown[],\n  argIndex: number,\n  input: any,\n) => {\n  if (argIndex === 0) {\n    return input\n  }\n\n  if (Array.isArray(items)) {\n    return { ...input, Args: { item: items[0], index: 0 } }\n  }\n  if (items && typeof items === 'object') {\n    const [first] = Object.entries(items)\n    if (first) {\n      return { ...input, Args: { value: first[1], key: first[0] } }\n    }\n  }\n  return input\n}\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nexport const handler: FormulaHandler<unknown> = ([items, fx]) => {\n  if (typeof fx !== 'function') {\n    // throw new Error(\"Argument 'Formula' must be of type formula\")\n    return null\n  }\n  if (Array.isArray(items)) {\n    return items.find((item, index) => fx({ item, index }))\n  }\n  if (items && typeof items === 'object') {\n    return Object.entries(items).find(([key, value]) => fx({ key, value }))?.[1]\n  }\n  // throw new Error(\"Argument 'Array' must be of type object or array\")\n  return null\n}\n\nexport default handler\n\nexport const getArgumentInputData = (\n  [items]: unknown[],\n  argIndex: number,\n  input: any,\n) => {\n  if (argIndex === 0) {\n    return input\n  }\n\n  if (Array.isArray(items)) {\n    return { ...input, Args: { item: items[0], index: 0 } }\n  }\n  if (items && typeof items === 'object') {\n    const [first] = Object.entries(items)\n    if (first) {\n      return { ...input, Args: { key: first[0], value: first[1] } }\n    }\n  }\n  return input\n}\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<{\n  hostname: string\n  searchParams: Record<string, string>\n  path: string[]\n  hash: string\n  href: string\n  protocol: string\n  port: string\n  origin: string\n}> = ([url, base]) => {\n  if (typeof url !== 'string') {\n    // throw new Error(`Invalid parameter type \"${typeof url}\" for URL`)\n    return null\n  }\n  try {\n    const {\n      hostname,\n      searchParams,\n      pathname,\n      hash,\n      href,\n      protocol,\n      port,\n      origin,\n    } = new URL(url, typeof base === 'string' ? base : undefined)\n    return {\n      hostname,\n      searchParams: Object.fromEntries(searchParams),\n      // Remove the first \"empty\" path parameter and return path parameters as an array\n      path: pathname.split('/').filter((p, i) => i !== 0 || p !== ''),\n      // Remove the leading '#' (havel\u00E5ge)\n      hash: hash.replace('#', ''),\n      href,\n      protocol,\n      port,\n      origin,\n    }\n  } catch {\n    // Invalid url\n    return null\n  }\n}\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown> | string> = ([list, count]) => {\n  if (typeof count !== 'number' || isNaN(count)) {\n    // throw new Error(\"Argument 'Count' must be of type number\")\n    return null\n  }\n  if (Array.isArray(list)) {\n    return list.slice(count)\n  }\n  if (typeof list === 'string') {\n    return list.substring(count)\n  }\n  // throw new Error('Argument Array must be of type array or list')\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<unknown> = ([list]) => {\n  if (typeof list === 'string' || Array.isArray(list)) {\n    return list[list.length - 1]\n  }\n  // throw new Error(\"Argument 'Array' must be of type array\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([value, min, max]) => {\n  if (typeof value !== 'number') {\n    // throw new Error(\"Argument 'Value' must be of type number\")\n    return null\n  }\n  if (typeof min !== 'number') {\n    // throw new Error(\"Argument 'Min' must be of type number\")\n    return null\n  }\n  if (typeof max !== 'number') {\n    // throw new Error(\"Argument 'Max' must be of type number\")\n    return null\n  }\n  return Math.min(Math.max(value, min), max)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = (_, { env }) =>\n  env.isServer ? env.request.url : (window?.location.href ?? null)\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown> | Record<string, unknown>> = ([\n  items,\n  fx,\n]) => {\n  if (typeof fx !== 'function') {\n    // throw new Error(\"Argument 'Formula' must be of type formula\")\n    return null\n  }\n  if (Array.isArray(items)) {\n    return items.map((item, index) => fx({ item, index }))\n  }\n  if (items && typeof items === 'object') {\n    return Object.fromEntries(\n      Object.entries(items).map<any>(([key, value]) => {\n        const res = fx({ key, value })\n        if ('key' in res && 'value' in res) {\n          return [res.key, res.value]\n        }\n        return null\n      }),\n    )\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or object\")\n  return null\n}\n\nexport const getArgumentInputData = (\n  [items]: unknown[],\n  argIndex: number,\n  input: any,\n) => {\n  if (argIndex === 0) {\n    return input\n  }\n  if (Array.isArray(items)) {\n    return { ...input, Args: { item: items[0], index: 0 } }\n  }\n  if (items && typeof items === 'object') {\n    const [first] = Object.entries(items)\n    if (first) {\n      return { ...input, Args: { key: first[0], value: first[1] } }\n    }\n  }\n  return input\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([a, b]) => {\n  if (isNaN(Number(a)) || isNaN(Number(b))) {\n    return null\n  }\n  return Number(a) % Number(b)\n}\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<HTMLElement> = ([id], { root }) => {\n  if (typeof id !== 'string') {\n    // throw new Error(\"Argument 'Id' must be a string\")\n    return null\n  }\n\n  return root.getElementById(id)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([\n  input,\n  searchValue,\n  replaceValue,\n]) => {\n  if (typeof input !== 'string') {\n    // throw new Error(\n    //   `Argument 'Input' must be a string, received ${typeof input}`,\n    // )\n    return null\n  }\n\n  if (typeof searchValue !== 'string') {\n    // throw new Error(\n    //   `Argument 'Search value' must be a string, received ${typeof searchValue}`,\n    // )\n    return null\n  }\n\n  return input.replaceAll(searchValue, String(replaceValue))\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nexport const handler: FormulaHandler<number> = ([items, fx]: unknown[]) => {\n  if (typeof fx !== 'function') {\n    // throw new Error(\"Argument 'Formula' must be of type formula\")\n    return null\n  }\n  if (Array.isArray(items)) {\n    return items.findIndex((item, index) => fx({ item, index }))\n  }\n  if (items && typeof items === 'object') {\n    return Object.entries(items).findIndex(([key, value]) => fx({ key, value }))\n  }\n  // throw new Error(\"Argument 'Array' must be of type object or array\")\n  return null\n}\n\nexport default handler\n\nexport const getArgumentInputData = (\n  [items]: unknown[],\n  argIndex: number,\n  input: any,\n) => {\n  if (argIndex === 0) {\n    return input\n  }\n\n  if (Array.isArray(items)) {\n    return { ...input, Args: { item: items[0], index: 0 } }\n  }\n  if (items && typeof items === 'object') {\n    const [first] = Object.entries(items)\n    if (first) {\n      return { ...input, Args: { key: first[0], value: first[1] } }\n    }\n  }\n  return input\n}\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = (_, ctx) => {\n  return ctx.env.branchName\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([input]) => {\n  if (typeof input !== 'string') {\n    // throw new Error(\"Argument 'Input' must be a string\")\n    return null\n  }\n  return atob(input)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([input]) => String(input)\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nimport { isObject } from '@toddledev/core/dist/utils/util'\n\nconst handler: FormulaHandler<string> = (items) => {\n  if (items.every(Array.isArray)) {\n    const result = []\n    for (const item of items) {\n      result.push(...item)\n    }\n    return result\n  }\n  if (items.every(isObject)) {\n    return Object.assign({}, ...items)\n  }\n  return items.join('')\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nconst handler: FormulaHandler<string> = ([data, indent]) => {\n  if (typeof indent !== 'number') {\n    // throw new Error(\"Argument 'indent' must be of type number\")\n    return null\n  }\n  return JSON.stringify(data, null, indent)\n}\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<unknown> = ([key]) => {\n  if (typeof key !== 'string' || key.length === 0) {\n    // throw new Error(`Invalid key: ${key}`)\n    return null\n  }\n  if (typeof window === 'undefined') {\n    return null\n  }\n  const value = window.sessionStorage.getItem(key)\n  if (value === null) {\n    return value\n  }\n  try {\n    return JSON.parse(value)\n  } catch {\n    return value\n  }\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nconst handler: FormulaHandler<boolean> = ([a, b]) => {\n  return (globalThis as any).toddle.isEqual(a, b)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown>> = ([list]) => {\n  if (!Array.isArray(list)) {\n    // throw new Error(\"Argument 'Array' must be of type array\")\n    return null\n  }\n  const set = new Set()\n  return list.filter((item) => {\n    const key = typeof item === 'object' ? JSON.stringify(item) : item\n    if (set.has(key)) {\n      return false\n    }\n    set.add(key)\n    return true\n  })\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown>> = ([list]) => {\n  if (Array.isArray(list)) {\n    return [...list].reverse()\n  }\n  // throw new Error(\"Argument 'Array' must be of type array\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<unknown> = ([list]) => {\n  if (typeof list === 'string' || Array.isArray(list)) {\n    return list[0]\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or string\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([a, b]) => {\n  const first = Number(a)\n  const second = Number(b)\n  if (isNaN(first) || isNaN(second)) {\n    // throw new Error('Both Arguments must be of type number')\n    return null\n  }\n  return first - second\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nexport const handler: FormulaHandler<Record<string, Array<unknown>>> = ([\n  items,\n  func,\n]) => {\n  if (typeof func !== 'function') {\n    // throw new Error(\"Argument 'Formula' must be of type formula\")\n    return null\n  }\n\n  if (!items || typeof items !== 'object' || !Array.isArray(items)) {\n    // throw new Error(\"Argument 'Array' must be of type array\")\n    return null\n  }\n\n  const res: Record<string, any> = {}\n\n  for (const index in items) {\n    const item = items[index]\n    const key = String(func({ item, index }))\n    res[key] = res[key] ?? []\n    res[key].push(item)\n  }\n  return res\n}\n\nexport default handler\n\nexport const getArgumentInputData = (\n  [items]: unknown[],\n  argIndex: number,\n  input: any,\n) => {\n  if (argIndex === 1 && Array.isArray(items)) {\n    return { ...input, Args: { item: items[0], index: 0 } }\n  }\n  return input\n}\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<unknown> = ([collection, key]) => {\n  if (typeof collection === 'string') {\n    return collection[Number(key)]\n  }\n  const resolve = (collection: any, path: unknown[]): unknown => {\n    if (path.length === 0) {\n      return collection\n    }\n    const [head, ...rest] = path\n    return resolve(collection?.[String(head)], rest)\n  }\n  return resolve(collection, Array.isArray(key) ? key : [key])\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown>> = ([list, value]) => {\n  if (!Array.isArray(list)) {\n    // throw new Error('The Array argument must be of type array')\n    return null\n  }\n  return [value, ...list]\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([a, b]) => {\n  if (isNaN(Number(a)) || isNaN(Number(b))) {\n    // throw new Error('Both arguments must be of type number')\n    return null\n  }\n  return Number(a) / Number(b)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Date> = ([date]) => {\n  if (typeof date === 'string') {\n    return new Date(date)\n  } else {\n    // throw new Error('Invalid input for Date')\n    return null\n  }\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([value]) => {\n  switch (typeof value) {\n    case 'number':\n      if (isNaN(value)) {\n        return null\n      }\n      return 'Number'\n    case 'string':\n      return 'String'\n    case 'boolean':\n      return 'Boolean'\n    case 'object':\n      return Array.isArray(value) ? 'Array' : value === null ? 'Null' : 'Object'\n\n    case 'undefined':\n      return 'Null'\n    default:\n      // throw new Error(\"Could not determine the type of the argument 'Input'\")\n      return null\n  }\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown> | string> = ([list, count]) => {\n  if (typeof count !== 'number') {\n    // throw new Error(\"Argument 'Count' must be of type number\")\n    return null\n  }\n  if (Array.isArray(list)) {\n    return list.slice(list.length - count)\n  }\n  if (typeof list === 'string') {\n    return list.substring(list.length - count)\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or string\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([a]) => {\n  if (typeof a !== 'number') {\n    // throw new Error('Argument must be a number')\n    return null\n  }\n  return Math.abs(a)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown> | string> = ([list, count]) => {\n  if (typeof count !== 'number' || isNaN(count)) {\n    // throw new Error('Argument Count must be of type number')\n    return null\n  }\n  if (Array.isArray(list)) {\n    return list.slice(0, list.length - count)\n  }\n  if (typeof list === 'string') {\n    return list.substring(0, list.length - count)\n  }\n  // throw new Error('Argument Array must be of type array or String')\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nimport { isObject } from '@toddledev/core/dist/utils/util'\n\nconst handler: FormulaHandler<Array<unknown> | Record<string, unknown>> = ([\n  collection,\n  key,\n]) => {\n  if (typeof collection !== 'object' || collection === null) {\n    // throw new Error(\"Argument 'Object' must be of type object or array\")\n    return null\n  }\n\n  if (\n    !Array.isArray(key) &&\n    typeof key !== 'string' &&\n    typeof key !== 'number'\n  ) {\n    // throw new Error(\"Argument 'Path' must be of type string, number or array\")\n    return null\n  }\n\n  const run = (\n    collection: any,\n    [key, ...path]: string[],\n  ): Record<string, any> | null => {\n    if (Array.isArray(collection)) {\n      const index = Number(key)\n      if (Number.isNaN(index)) {\n        return collection\n      }\n      if (path.length === 0) {\n        return collection.filter((_, i) => i !== Number(key))\n      }\n      return collection.map((e, i) =>\n        i === index ? run(collection[index], path) : e,\n      )\n    }\n    if (isObject(collection)) {\n      if (path.length === 0) {\n        return Object.fromEntries(\n          Object.entries(collection).filter(([k]) => k !== key),\n        )\n      }\n      return {\n        ...collection,\n        [key]: run(collection[key], path),\n      }\n    }\n\n    return null\n  }\n  const path = Array.isArray(key) ? key : [key]\n  return run(collection, path)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([date]) => {\n  if (!date || !(date instanceof Date)) {\n    // throw new Error('Invalid input for Date')\n    return null\n  }\n  return date.getTime()\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<{ key: string; value: unknown }>> = ([\n  object,\n]) => {\n  if (typeof object === 'object' && object !== null) {\n    return Object.entries(object).map(([key, value]) => ({ key, value }))\n  }\n  // throw new Error('Argument Object must be of type object')\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([str]) => {\n  if (typeof str !== 'string') {\n    // throw new Error(\"Argument 'String' must be of type string\")\n    return null\n  }\n  return str.trim()\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown>> = ([items]) => {\n  if (Array.isArray(items)) {\n    return items.flat()\n  }\n  // throw new Error(\"Argument 'Array' must be of type array\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([data, indentation]) => {\n  const indent = isNaN(Number(indentation)) ? 0 : Number(indentation)\n  return JSON.stringify(data, null, indent)\n}\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<boolean> = ([first, second]: any[]) => {\n  return first <= second\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Date> = () => {\n  return new Date()\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([n]) => {\n  if (typeof n !== 'number') {\n    // throw new Error(\"Argument 'Number' must be of type number\")\n    return null\n  }\n\n  return Math.sqrt(n)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown> | string> = ([list, count]) => {\n  if (typeof count !== 'number') {\n    // throw new Error(\"Argument 'Count' must be of type number\")\n    return null\n  }\n  if (Array.isArray(list)) {\n    return list.slice(0, count)\n  }\n  if (typeof list === 'string') {\n    return list.substring(0, count)\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or string\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown>> = ([list, value]) => {\n  if (!Array.isArray(list)) {\n    // throw new Error('The Array argument must be of type array')\n    return null\n  }\n  return [...list, value]\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<unknown> = ([key]) => {\n  if (typeof key !== 'string' || key.length === 0) {\n    // throw new Error(`Invalid key: ${key}`)\n    return null\n  }\n  if (typeof window === 'undefined') {\n    return null\n  }\n  const value = window.localStorage.getItem(key)\n  if (value === null) {\n    return value\n  }\n  try {\n    return JSON.parse(value)\n  } catch {\n    return value\n  }\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([a]) => Number(a)\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([input]) => {\n  if (typeof input !== 'string') {\n    // throw new Error(\"Argument 'Input' must be a string\")\n    return null\n  }\n  return btoa(input)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([list, separator]) => {\n  if (Array.isArray(list)) {\n    return list.join(String(separator))\n  }\n  // throw new Error(\"Argument 'Array' must be of type array\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<number>> = ([min, max]) => {\n  if (typeof min !== 'number') {\n    return null\n  }\n  if (typeof max !== 'number') {\n    return null\n  }\n  if (min > max) {\n    return []\n  }\n  return Array.from({ length: max - min + 1 }, (_, i) => i + min)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = (args) => {\n  return Math.max(...args.map(Number))\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<boolean> = ([first, second]: any[]) => {\n  return first < second\n}\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown> | string> = ([list]) => {\n  if (Array.isArray(list)) {\n    return shuffle(list)\n  }\n  if (typeof list === 'string') {\n    return shuffle(list.split('')).join('')\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or string\")\n  return null\n}\n\nfunction shuffle(input: Array<any>) {\n  const array = [...input]\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1)) // random index from 0 to i\n\n    // swap elements array[i] and array[j]\n    // we use \"destructuring assignment\" syntax to achieve that\n    // you'll find more details about that syntax in later chapters\n    // same can be written as:\n    // let t = array[i]; array[i] = array[j]; array[j] = t\n    ;[array[i], array[j]] = [array[j], array[i]]\n  }\n  return array\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([collection, item]) => {\n  if (typeof collection === 'string') {\n    return collection.lastIndexOf(item as any)\n  }\n\n  if (Array.isArray(collection)) {\n    return collection.findLastIndex((i) =>\n      (globalThis as any).toddle.isEqual(i, item),\n    )\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or string\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([a, b]) => {\n  if (isNaN(Number(a)) || isNaN(Number(b))) {\n    return null\n  }\n\n  return Number(a) ** Number(b)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([input, decimals]) => {\n  if (typeof input !== 'number') {\n    // throw new Error(\"Argument 'Input' must be of type number\")\n    return null\n  }\n  if (typeof decimals !== 'number') {\n    // throw new Error(\"Argument 'Decimals' must be of type number\")\n    return null\n  }\n\n  const multiplier = Math.max(1, Math.pow(10, decimals))\n  return Math.floor(input * multiplier) / multiplier\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nexport const handler: FormulaHandler<boolean> = ([items, fx]: unknown[]) => {\n  if (typeof fx !== 'function') {\n    // throw new Error('Argument Formula must be of type formula')\n    return null\n  }\n  if (Array.isArray(items)) {\n    return items.every((item, index) => fx({ item, index }))\n  }\n  if (items && typeof items === 'object') {\n    return Object.entries(items).every(([key, value]) => fx({ key, value }))\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or object\")\n  return null\n}\n\nexport default handler\n\nexport const getArgumentInputData = (\n  [items]: unknown[],\n  argIndex: number,\n  input: any,\n) => {\n  if (argIndex === 0) {\n    return input\n  }\n\n  if (Array.isArray(items)) {\n    return { ...input, Args: { item: items[0], index: 0 } }\n  }\n  if (items && typeof items === 'object') {\n    const [first] = Object.entries(items)\n    if (first) {\n      return { ...input, Args: { key: first[0], value: first[1] } }\n    }\n  }\n  return input\n}\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nexport const handler: FormulaHandler<Record<string, Array<unknown>>> = ([\n  items,\n  func,\n]) => {\n  if (typeof func !== 'function') {\n    // throw new Error(\"Argument 'Formula' must be of type formula\")\n    return null\n  }\n\n  if (!items || typeof items !== 'object') {\n    // throw new Error(\"Argument 'Array' must be of type array\")\n    return null\n  }\n\n  const list = Array.isArray(items) ? items : Object.entries(items)\n\n  const res: Record<string, any> = {}\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i]\n    const key = String(func({ item, i }))\n    res[key] = item\n  }\n  return res\n}\n\nexport default handler\n\nexport const getArgumentInputData = (\n  [items]: unknown[],\n  argIndex: number,\n  input: any,\n) => {\n  if (argIndex === 0) {\n    return input\n  }\n\n  if (Array.isArray(items)) {\n    return { ...input, Args: { item: items[0], index: 0 } }\n  }\n  if (items && typeof items === 'object') {\n    const [first] = Object.entries(items)\n    if (first) {\n      return { ...input, Args: { value: first[1], key: first[0] } }\n    }\n  }\n  return input\n}\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nimport { parseJSONWithDate } from '@toddledev/core/dist/utils/json'\n\nconst handler: FormulaHandler<unknown> = ([data]) => {\n  if (typeof data !== 'string') {\n    // throw new Error(\"Argument 'JSON string' must be of type string\")\n    return null\n  }\n  try {\n    return parseJSONWithDate(data)\n  } catch {\n    return null\n  }\n}\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([date, loc, opt]) => {\n  if (!date || !(date instanceof Date)) {\n    // throw new Error('Invalid input for Date')\n    return null\n  }\n  const locales =\n    typeof loc === 'string' && loc.length > 0\n      ? loc\n      : Array.isArray(loc) && loc.every((l) => typeof l === 'string')\n        ? (loc as string[])\n        : undefined\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!opt || typeof opt !== 'object') {\n    return Intl.DateTimeFormat(locales).format(date)\n  }\n  const validateString = <T = string>(\n    value: unknown,\n    allowedValues?: string[],\n  ): T | undefined =>\n    typeof value === 'string' && (allowedValues?.includes(value) ?? true)\n      ? (value as T)\n      : undefined\n\n  const options: Partial<\n    Intl.DateTimeFormatOptions & { locale: string | string[] }\n  > = opt\n  const dateStyle = validateString<Intl.DateTimeFormatOptions['dateStyle']>(\n    options.dateStyle,\n    ['full', 'long', 'medium', 'short'],\n  )\n  const timeStyle = validateString<Intl.DateTimeFormatOptions['timeStyle']>(\n    options.timeStyle,\n    ['full', 'long', 'medium', 'short'],\n  )\n  const calendar = validateString(options.calendar)\n  const weekday = validateString<Intl.DateTimeFormatOptions['weekday']>(\n    options.weekday,\n    ['long', 'short', 'narrow'],\n  )\n  const era = validateString<Intl.DateTimeFormatOptions['era']>(options.era, [\n    'long',\n    'short',\n    'narrow',\n  ])\n  const year = validateString<Intl.DateTimeFormatOptions['year']>(\n    options.year,\n    ['numeric', '2-digit'],\n  )\n  const month = validateString<Intl.DateTimeFormatOptions['month']>(\n    options.month,\n    ['long', 'short', 'narrow', 'numeric', '2-digit'],\n  )\n  const day = validateString<Intl.DateTimeFormatOptions['day']>(options.day, [\n    'numeric',\n    '2-digit',\n  ])\n  const hour = validateString<Intl.DateTimeFormatOptions['hour']>(\n    options.hour,\n    ['numeric', '2-digit'],\n  )\n  const minute = validateString<Intl.DateTimeFormatOptions['minute']>(\n    options.minute,\n    ['numeric', '2-digit'],\n  )\n  const second = validateString<Intl.DateTimeFormatOptions['second']>(\n    options.second,\n    ['numeric', '2-digit'],\n  )\n  const timeZoneName = validateString<\n    Intl.DateTimeFormatOptions['timeZoneName']\n  >(options.timeZoneName, [\n    'long',\n    'short',\n    'shortOffset',\n    'longOffset',\n    'shortGeneric',\n    'longGeneric',\n  ])\n  const timeZone = validateString<Intl.DateTimeFormatOptions['timeZone']>(\n    options.timeZone,\n  )\n  const hour12 =\n    options.hour12 === true\n      ? true\n      : options.hour12 === false\n        ? false\n        : undefined\n\n  return Intl.DateTimeFormat(locales, {\n    dateStyle,\n    timeStyle,\n    calendar,\n    weekday,\n    era,\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    timeZoneName,\n    timeZone,\n    hour12,\n  }).format(date)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nimport { toBoolean } from '@toddledev/core/dist/utils/util'\n\nconst handler: FormulaHandler<Array<string>> = ([\n  inputString,\n  regex,\n  globalFlag,\n  ignoreCaseFlag,\n  multiLineFlag,\n]) => {\n  if (typeof inputString !== 'string' || typeof regex !== 'string') {\n    return []\n  }\n  const flags = [\n    toBoolean(globalFlag) ? 'g' : '',\n    toBoolean(ignoreCaseFlag) ? 'i' : '',\n    toBoolean(multiLineFlag) ? 'm' : '',\n  ].join('')\n\n  const re = new RegExp(regex, flags)\n  return inputString.match(re) ?? []\n}\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([list]) => {\n  if (Array.isArray(list)) {\n    let sum = 0\n    for (const n of list) {\n      if (isNaN(n) || typeof n !== 'number') {\n        // throw new Error('The Array must only contain numbers')\n        return null\n      }\n      sum += n\n    }\n    return sum\n  }\n  // throw new Error('The Array argument must be of type array')\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nconst handler: FormulaHandler<boolean> = ([collection, prefix]) => {\n  if (typeof collection !== 'string') {\n    // throw new Error(\"Argument 'String' must be of type string\")\n    return null\n  }\n  if (typeof prefix !== 'string') {\n    // throw new Error(\"Argument 'Prefix' must be of type string\")\n    return null\n  }\n\n  return collection.startsWith(prefix)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Date> = ([timestamp]) => {\n  if (typeof timestamp === 'number') {\n    return new Date(timestamp)\n  } else {\n    // throw new Error('Invalid input for Date')\n    return null\n  }\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<readonly string[]> = (_, { env }) => {\n  if (!env.isServer) {\n    return window.navigator.languages\n  } else {\n    return (\n      env.request?.headers['accept-language']\n        ?.split(',')\n        .map((lang) => lang.split(';')[0]) ?? []\n    )\n  }\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<Array<unknown>> = ([inputString, delimiter]) => {\n  if (typeof inputString !== 'string') {\n    // throw new Error(\"Argument 'Input' must be of type string\")\n    return null\n  }\n  if (typeof delimiter !== 'string') {\n    // throw new Error(\"Argument 'Delimeter' must be of type string\")\n    return null\n  }\n  return inputString.split(delimiter)\n}\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nimport { isObject } from '@toddledev/core/dist/utils/util'\n\nconst handler: FormulaHandler<number> = ([collection]) => {\n  if (Array.isArray(collection)) {\n    return collection.length\n  }\n  if (isObject(collection)) {\n    return Object.keys(collection).length\n  }\n  if (typeof collection === 'string') {\n    return collection.length\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or string\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<boolean> = (_, ctx) => {\n  return ctx.env.isServer\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([name], { env, root }) => {\n  if (!name || typeof name !== 'string') {\n    return null\n  }\n  if (!env.isServer) {\n    if (root instanceof ShadowRoot) {\n      return null\n    }\n    return (\n      root.cookie\n        .split('; ')\n        ?.find((row) => row.startsWith(`${name}=`))\n        ?.split('=')[1] ?? null\n    )\n  } else {\n    return env.request.cookies[name] ?? null\n  }\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\nimport { toBoolean } from '@toddledev/core/dist/utils/util'\n\nconst handler: FormulaHandler<boolean> = ([input]) => {\n  return toBoolean(input)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = ([collection, item]) => {\n  if (typeof collection === 'string') {\n    return collection.indexOf(item as any)\n  }\n\n  if (Array.isArray(collection)) {\n    return collection.findIndex((i) =>\n      (globalThis as any).toddle.isEqual(i, item),\n    )\n  }\n  // throw new Error(\"Argument 'Array' must be of type array or string\")\n  return null\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([input]) => {\n  if (typeof input !== 'string') {\n    // throw new Error(\"Argument 'String' must be of type string\")\n    return null\n  }\n  if (input.length === 0) {\n    return input\n  }\n  return input[0].toLocaleUpperCase() + input.substring(1).toLocaleLowerCase()\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([input]) => {\n  if (typeof input !== 'string') {\n    // throw new Error(\"Argument 'String' must be of type string\")\n    return null\n  }\n  return input.toLocaleLowerCase()\n}\n\nexport default handler\n", "import { STRING_TEMPLATE } from '@toddledev/core/dist/api/template'\nimport type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([name]) => {\n  if (!name || typeof name !== 'string') {\n    return null\n  }\n  return STRING_TEMPLATE('cookies', name)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<string> = ([input, loc, opt]) => {\n  if (typeof input !== 'number' || Number.isNaN(input)) {\n    return null\n  }\n  const locales =\n    typeof loc === 'string' && loc.length > 0\n      ? loc\n      : Array.isArray(loc) && loc.every((l) => typeof l === 'string')\n        ? (loc as string[])\n        : undefined\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!opt || typeof opt !== 'object') {\n    return Intl.NumberFormat(locales).format(input)\n  }\n  const validateString = <T = string>(\n    value: unknown,\n    allowedValues?: string[],\n  ): T | undefined =>\n    typeof value === 'string' && (allowedValues?.includes(value) ?? true)\n      ? (value as T)\n      : undefined\n\n  const options: Partial<\n    Intl.NumberFormatOptions & { locale: string | string[] }\n  > = opt\n  const style = validateString<Intl.NumberFormatOptions['style']>(\n    options.style,\n    ['decimal', 'currency', 'percent', 'unit'],\n  )\n  const currency =\n    typeof options.currency === 'string' && options.currency.length === 3\n      ? options.currency\n      : undefined\n  if (style === 'currency' && typeof currency !== 'string') {\n    // currency must be provided when style is currency\n    return null\n  }\n  const currencyDisplay = validateString<\n    Intl.NumberFormatOptions['currencyDisplay']\n  >(options.currencyDisplay, ['code', 'symbol', 'narrowSymbol', 'name'])\n  const unit = typeof options.unit === 'string' ? options.unit : undefined\n  if (style === 'unit' && typeof unit !== 'string') {\n    // unit must be provided when style is unit\n    return null\n  }\n  const unitDisplay = validateString<Intl.NumberFormatOptions['unitDisplay']>(\n    options.unitDisplay,\n    ['short', 'narrow', 'long'],\n  )\n  const minimumIntegerDigits =\n    typeof options.minimumIntegerDigits === 'number' &&\n    options.minimumIntegerDigits >= 1 &&\n    options.minimumIntegerDigits <= 21\n      ? options.minimumIntegerDigits\n      : undefined\n  const minimumFractionDigits =\n    typeof options.minimumFractionDigits === 'number' &&\n    options.minimumFractionDigits >= 0 &&\n    options.minimumFractionDigits <= 100\n      ? options.minimumFractionDigits\n      : undefined\n  const maximumFractionDigits =\n    typeof options.maximumFractionDigits === 'number' &&\n    options.maximumFractionDigits >= 0 &&\n    options.maximumFractionDigits <= 100\n      ? options.maximumFractionDigits\n      : undefined\n  const minimumSignificantDigits =\n    typeof options.minimumSignificantDigits === 'number' &&\n    options.minimumSignificantDigits >= 1 &&\n    options.minimumSignificantDigits <= 21\n      ? options.minimumSignificantDigits\n      : undefined\n  const maximumSignificantDigits =\n    typeof options.maximumSignificantDigits === 'number' &&\n    options.maximumSignificantDigits >= 1 &&\n    options.maximumSignificantDigits <= 21\n      ? options.maximumSignificantDigits\n      : undefined\n  const notation = validateString<Intl.NumberFormatOptions['notation']>(\n    options.notation,\n    ['standard', 'scientific', 'engineering', 'compact'],\n  )\n  const compactDisplay = validateString<\n    Intl.NumberFormatOptions['compactDisplay']\n  >(options.compactDisplay, ['short', 'long'])\n\n  // useGrouping can be a boolean, 'always', 'auto', or 'min2'\n  const validGroupingValues: Array<\n    keyof Intl.NumberFormatOptionsUseGroupingRegistry\n  > = ['always', 'auto', 'min2']\n  const useGrouping: Intl.NumberFormatOptions['useGrouping'] =\n    typeof options.useGrouping === 'boolean'\n      ? options.useGrouping\n      : validateString<keyof Intl.NumberFormatOptionsUseGroupingRegistry>(\n          options.useGrouping,\n          validGroupingValues,\n        )\n\n  return new Intl.NumberFormat(locales, {\n    style,\n    currency,\n    currencyDisplay,\n    unit,\n    unitDisplay,\n    minimumIntegerDigits,\n    minimumFractionDigits,\n    maximumFractionDigits,\n    minimumSignificantDigits,\n    maximumSignificantDigits,\n    notation,\n    compactDisplay,\n    useGrouping,\n  }).format(input)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<number> = (numbers) => {\n  if (\n    !Array.isArray(numbers) ||\n    numbers.some((n) => n === null || typeof n !== 'number')\n  ) {\n    // throw new Error('All inputs must be of type number')\n    return null\n  }\n  return numbers.reduce((result: number, n: any) => {\n    return result + Number(n)\n  }, 0)\n}\n\nexport default handler\n", "import type { FormulaHandler } from '@toddledev/core/dist/types'\n\nconst handler: FormulaHandler<boolean> = ([first, second]: any[]) => {\n  return first >= second\n}\n\nexport default handler\n", "/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\", delimiter = \"/#?\" } = options;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  const isSafe = (value: string): boolean => {\n    for (const char of delimiter) if (value.indexOf(char) > -1) return true;\n    return false;\n  };\n\n  const safePattern = (prefix: string) => {\n    const prev = result[result.length - 1];\n    const prevText = prefix || (prev && typeof prev === \"string\" ? prev : \"\");\n\n    if (prev && !prevText) {\n      throw new TypeError(\n        `Must have text between two parameters, missing text after \"${(prev as Key).name}\"`,\n      );\n    }\n\n    if (!prevText || isSafe(prevText)) return `[^${escapeString(delimiter)}]+?`;\n    return `(?:(?!${escapeString(prevText)})[^${escapeString(delimiter)}])+?`;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || safePattern(prefix),\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? safePattern(prefix) : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions,\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {},\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`,\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string,\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions,\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {},\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {},\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            throw new TypeError(\n              `Can not repeat \"${token.name}\" without a prefix and suffix`,\n            );\n          }\n\n          route += `(${token.pattern})${token.modifier}`;\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "/* eslint-disable @typescript-eslint/no-floating-promises */\nimport type { LegacyComponentAPI } from '@toddledev/core/dist/api/apiTypes'\nimport type { ComponentData } from '@toddledev/core/dist/component/component.types'\nimport { applyFormula, isFormula } from '@toddledev/core/dist/formula/formula'\nimport { mapValues } from '@toddledev/core/dist/utils/collections'\nimport { parseJSONWithDate } from '@toddledev/core/dist/utils/json'\nimport { handleAction } from '../events/handleAction'\nimport type { Signal } from '../signal/signal'\nimport type { ComponentContext } from '../types'\n\nexport type ApiRequest = {\n  url: string\n  method: 'GET' | 'POST' | 'DELETE' | 'PUT' | 'OPTION' | 'HEAD'\n  auth: { type: string } | undefined\n  headers: Record<string, string>\n  body: any\n}\n\n/**\n * Set up an api for a component.\n * API requests are either proxied through toddle's back-end\n * or sent directly to the api endpoint (when api.proxy === false)\n */\nexport function createLegacyAPI(\n  api: LegacyComponentAPI,\n  ctx: ComponentContext,\n): { fetch: Function; destroy: Function } {\n  let timer: any = null\n\n  // Create the payload we send to toddle's back-end\n  // This includes url, headers, and content, sent in the body of a post request to /_query/<ComponentName>.<QueryName>\n  function constructPayload(\n    api: LegacyComponentAPI,\n    data: ComponentData,\n  ): ApiRequest {\n    const formulaContext = {\n      data,\n      component: ctx.component,\n      formulaCache: ctx.formulaCache,\n      root: ctx.root,\n      package: ctx.package,\n      toddle: ctx.toddle,\n      env: ctx.env,\n    }\n\n    // construct the url\n    const baseUrl = applyFormula(api.url, formulaContext) ?? ''\n    const urlPath =\n      api.path && api.path.length > 0\n        ? '/' +\n          api.path.map((p) => applyFormula(p.formula, formulaContext)).join('/')\n        : ''\n\n    // build querystring\n    const queryParams = Object.values(api.queryParams ?? {})\n    const queryString =\n      queryParams.length > 0\n        ? '?' +\n          queryParams\n            .map(\n              (param) =>\n                `${param.name}=${encodeURIComponent(\n                  applyFormula(param.formula, formulaContext),\n                )}`,\n            )\n            .join('&')\n        : ''\n    const headers = isFormula(api.headers) // this is supporting a few legacy cases where the whole header object was set as a formula. This is no longer possible\n      ? applyFormula(api.headers, {\n          data,\n          component: ctx.component,\n          formulaCache: ctx.formulaCache,\n          root: ctx.root,\n          package: ctx.package,\n          toddle: ctx.toddle,\n          env: ctx.env,\n        })\n      : mapValues(api.headers ?? {}, (value) =>\n          applyFormula(value, {\n            data,\n            component: ctx.component,\n            formulaCache: ctx.formulaCache,\n            root: ctx.root,\n            package: ctx.package,\n            toddle: ctx.toddle,\n            env: ctx.env,\n          }),\n        )\n    const contentType = String(\n      Object.entries(headers).find(\n        ([key]) => key.toLocaleLowerCase() === 'content-type',\n      )?.[1],\n    )\n    const method = api.method ?? 'GET'\n    const body =\n      api.body && ['POST', 'PUT', 'PATCH', 'DELETE'].includes(method)\n        ? encodeBody(\n            applyFormula(api.body, {\n              data,\n              component: ctx.component,\n              formulaCache: ctx.formulaCache,\n              root: ctx.root,\n              package: ctx.package,\n              toddle: ctx.toddle,\n              env: ctx.env,\n            }),\n            contentType,\n          )\n        : undefined\n    return {\n      url: baseUrl + urlPath + queryString,\n      method,\n      auth: api.auth,\n      headers,\n      body,\n    }\n  }\n\n  // extract the response body\n  async function getBody(res: Response) {\n    const textBody = await res.text()\n    try {\n      return parseJSONWithDate(textBody)\n    } catch {\n      return textBody\n    }\n  }\n\n  function encodeBody(body: any, contentType?: string): FormData | string {\n    switch (contentType) {\n      case 'application/x-www-form-urlencoded': {\n        if (typeof body === 'object' && body !== null) {\n          return Object.entries(body)\n            .map(([key, value]) => {\n              if (Array.isArray(value)) {\n                return value\n                  .map(\n                    (v) =>\n                      `${encodeURIComponent(key)}=${encodeURIComponent(v)}`,\n                  )\n                  .join('&')\n              } else {\n                return `${encodeURIComponent(key)}=${encodeURIComponent(\n                  String(value),\n                )}`\n              }\n            })\n            .join('&')\n        }\n        return ''\n      }\n      case 'multipart/form-data': {\n        const formData = new FormData()\n        if (typeof body === 'object' && body !== null) {\n          Object.entries(body).forEach(([key, value]) => {\n            formData.set(key, value as string | Blob)\n          })\n        }\n        return formData\n      }\n      case 'text/plain':\n        return String(body)\n      default:\n        return JSON.stringify(body)\n    }\n  }\n\n  function apiSuccess(data: any) {\n    ctx.dataSignal.set({\n      ...ctx.dataSignal.get(),\n      Apis: {\n        ...ctx.dataSignal.get().Apis,\n        [api.name]: {\n          data,\n          error: null,\n          isLoading: false,\n        },\n      },\n    })\n    api.onCompleted?.actions?.forEach((action) => {\n      handleAction(action, ctx.dataSignal.get(), ctx)\n    })\n  }\n\n  function apiError(error: any) {\n    ctx.dataSignal.set({\n      ...ctx.dataSignal.get(),\n      Apis: {\n        ...ctx.dataSignal.get().Apis,\n        [api.name]: {\n          data: null,\n          isLoading: false,\n          error: error,\n        },\n      },\n    })\n    api.onFailed?.actions?.forEach((action) => {\n      handleAction(action, ctx.dataSignal.get(), ctx)\n    })\n  }\n\n  // Execute the request to the cloudflare Query proxy\n  async function execute(payload: ApiRequest) {\n    ctx.dataSignal.set({\n      ...ctx.dataSignal.get(),\n      Apis: {\n        ...ctx.dataSignal.get().Apis,\n        [api.name]: {\n          data: ctx.dataSignal.get().Apis?.[api.name]?.data ?? null,\n          isLoading: true,\n          error: null,\n        },\n      },\n    })\n    let response\n\n    try {\n      if (api.proxy === false) {\n        response = await fetch(payload.url, {\n          method: payload.method,\n          headers: payload.headers,\n          body: payload.body,\n        })\n      } else {\n        response = await fetch(\n          `/_query/${encodeURIComponent(\n            ctx.component.name,\n          )}.${encodeURIComponent(api.name)}`,\n          {\n            method: 'POST',\n            body: JSON.stringify(payload),\n            signal: ctx.abortSignal,\n            headers: {\n              'Content-Type': 'application/json',\n            },\n          },\n        )\n      }\n      const data = await getBody(response)\n      if (response.ok) {\n        apiSuccess(data)\n      } else {\n        throw data\n      }\n    } catch (error: any) {\n      apiError(error)\n      return Promise.reject(error)\n    }\n  }\n\n  // Handles throttle and debounce if set.\n  function trigger(body: ApiRequest) {\n    if (typeof api.debounce === 'number') {\n      return new Promise((resolve, reject) => {\n        if (typeof timer === 'number') {\n          clearTimeout(timer)\n        }\n        timer = setTimeout(() => {\n          execute(body).then(resolve, reject)\n        }, api.debounce as number)\n      })\n    } else if (typeof api.throttle === 'number') {\n      if (typeof timer === 'number') {\n        return new Promise(() => {})\n      }\n      timer = setTimeout(() => {\n        if (typeof timer === 'number') {\n          clearTimeout(timer)\n        }\n      }, api.throttle)\n      return execute(body)\n    } else {\n      return execute(body)\n    }\n  }\n\n  let payloadSignal: Signal<ApiRequest> | undefined\n  ctx.dataSignal.update((data) => {\n    return {\n      ...data,\n      Apis: {\n        ...(data.Apis ?? {}),\n        [api.name]: data.Apis?.[api.name] ?? {\n          data: null,\n          isLoading:\n            api.autoFetch &&\n            applyFormula(api.autoFetch, {\n              data: ctx.dataSignal.get(),\n              component: ctx.component,\n              formulaCache: ctx.formulaCache,\n              root: ctx.root,\n              package: ctx.package,\n              toddle: ctx.toddle,\n              env: ctx.env,\n            })\n              ? true\n              : false,\n          error: null,\n        },\n      },\n    }\n  })\n  if (api.autoFetch) {\n    payloadSignal = ctx.dataSignal.map((data) => constructPayload(api, data))\n    let firstRun = true\n    payloadSignal.subscribe((body) => {\n      if (\n        api.autoFetch &&\n        applyFormula(api.autoFetch, {\n          data: ctx.dataSignal.get(),\n          component: ctx.component,\n          formulaCache: ctx.formulaCache,\n          root: ctx.root,\n          package: ctx.package,\n          toddle: ctx.toddle,\n          env: ctx.env,\n        })\n      ) {\n        // We should only lookup cached data for pages since\n        // we don't fetch data for component APIs during SSR\n        if (firstRun && ctx.isRootComponent) {\n          firstRun = false\n          const cached = ctx.toddle?.pageState?.Apis?.[api.name]\n          if (cached && cached.data) {\n            if (typeof cached.data === 'string') {\n              // Mimic the behavior from getBody and parse\n              // the response to JSON if possible\n              apiSuccess(parseJSONWithDate(cached.data))\n            } else {\n              apiSuccess(cached.data)\n            }\n          } else {\n            trigger(body)\n          }\n        } else {\n          trigger(body)\n        }\n      }\n    })\n  }\n  return {\n    fetch: (request?: ApiRequest) => {\n      const apiPayload = constructPayload(api, ctx.dataSignal.get())\n      let body = apiPayload.body\n      // Use a Headers object since it's case insensitive\n      const headers = new Headers({\n        ...apiPayload.headers,\n        ...(request?.headers ?? {}),\n      })\n      if (request?.body) {\n        body = encodeBody(\n          request.body,\n          headers.get('Content-Type') ?? undefined,\n        )\n      }\n      if (body instanceof FormData) {\n        // Remove content type header if body is a FormData object\n        // Otherwise fetch won't do its magic when sending the request\n        headers.delete('Content-Type')\n      }\n      const payload: ApiRequest = {\n        url: request?.url ?? apiPayload.url,\n        method: request?.method ?? apiPayload.method,\n        auth: request?.auth ?? apiPayload.auth,\n        headers: [...headers.entries()].reduce<Record<string, string>>(\n          (acc, [key, value]) => ({ ...acc, [key]: value }),\n          {},\n        ),\n        body,\n      }\n      return trigger(payload)\n    },\n    destroy: () => payloadSignal?.destroy(),\n  }\n}\n", "import type {\n  ActionModel,\n  ComponentData,\n} from '@toddledev/core/dist/component/component.types'\nimport { applyFormula } from '@toddledev/core/dist/formula/formula'\nimport { mapValues, omitKeys } from '@toddledev/core/dist/utils/collections'\nimport { isDefined, toBoolean } from '@toddledev/core/dist/utils/util'\nimport type { ComponentContext } from '../types'\n\n// eslint-disable-next-line max-params\nexport function handleAction(\n  action: ActionModel,\n  data: ComponentData,\n  ctx: ComponentContext,\n  event?: Event,\n) {\n  try {\n    if (!action) {\n      throw new Error('Action does not exist')\n    }\n    switch (action.type) {\n      case 'Switch': {\n        // find the first case that resolves to true.\n        // Only one case in a switch will be executed.\n        const actionList =\n          action.cases.find(({ condition }) =>\n            toBoolean(\n              applyFormula(condition, {\n                data,\n                component: ctx.component,\n                formulaCache: ctx.formulaCache,\n                root: ctx.root,\n                package: ctx.package,\n                toddle: ctx.toddle,\n                env: ctx.env,\n              }),\n            ),\n          ) ?? action.default\n        if (!actionList) {\n          return\n        }\n        // handle all actions for the case\n        for (const action of actionList.actions) {\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          handleAction(action, { ...data, ...ctx.dataSignal.get() }, ctx, event)\n        }\n        break\n      }\n      case 'SetVariable': {\n        const value = applyFormula(action.data, {\n          data,\n          component: ctx.component,\n          formulaCache: ctx.formulaCache,\n          root: ctx.root,\n          package: ctx.package,\n          toddle: ctx.toddle,\n          env: ctx.env,\n        })\n        ctx.dataSignal.update((data) => {\n          return {\n            ...data,\n            Variables: {\n              ...data.Variables,\n              [action.variable]: value,\n            },\n          }\n        })\n        break\n      }\n      case 'TriggerEvent': {\n        const payload = applyFormula(action.data, {\n          data,\n          component: ctx.component,\n          formulaCache: ctx.formulaCache,\n          root: ctx.root,\n          package: ctx.package,\n          toddle: ctx.toddle,\n          env: ctx.env,\n        })\n        ctx.triggerEvent(action.event, payload)\n        break\n      }\n      case 'SetURLParameter': {\n        ctx.toddle.locationSignal.update((current) => {\n          const value = applyFormula(action.data, {\n            data,\n            component: ctx.component,\n            formulaCache: ctx.formulaCache,\n            root: ctx.root,\n            package: ctx.package,\n            toddle: ctx.toddle,\n            env: ctx.env,\n          })\n          if (current.route?.path.some((p) => p.name === action.parameter)) {\n            return {\n              ...current,\n              params: {\n                ...omitKeys(current.params, [action.parameter]),\n                [action.parameter]: value,\n              },\n            }\n          } else {\n            return {\n              ...current,\n              query: {\n                ...omitKeys(current.query, [action.parameter]),\n                ...(isDefined(value) ? { [action.parameter]: value } : null),\n              },\n            }\n          }\n        })\n        break\n      }\n      case 'Fetch': {\n        const api = ctx.apis[action.api]\n        if (!api) {\n          console.error('The api ', action.api, 'does not exist')\n          return\n        }\n\n        const isv2 = ctx.component.apis?.[action.api]?.version === 2\n\n        // Evaluate potential inputs here to make sure the api have the right values\n        // This is needed if the inputs are formulas referencing workflow parameters\n        const actionInputs = isv2\n          ? mapValues(action.inputs ?? {}, (input) =>\n              applyFormula(input.formula, {\n                data,\n                component: ctx.component,\n                formulaCache: ctx.formulaCache,\n                root: ctx.root,\n                package: ctx.package,\n                toddle: ctx.toddle,\n                env: ctx.env,\n              }),\n            )\n          : undefined\n\n        const actionModels = isv2\n          ? {\n              onCompleted: action.onSuccess?.actions,\n              onFailed: action.onError?.actions,\n              onMessage: action.onMessage?.actions,\n            }\n          : undefined\n\n        const triggerActions = (actions: ActionModel[]) => {\n          // Actions from the fetch action is handled by the api itself\n          if (isv2) {\n            return\n          }\n          for (const subAction of actions) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            handleAction(\n              subAction,\n              { ...data, ...ctx.dataSignal.get() },\n              ctx,\n              event,\n            )\n          }\n        }\n\n        api.fetch({ actionInputs, actionModels }).then(\n          () => {\n            triggerActions(action.onSuccess.actions)\n          },\n          () => {\n            triggerActions(action.onError.actions)\n          },\n        )\n        break\n      }\n      case 'TriggerWorkflow': {\n        const parameters = mapValues(action.parameters ?? {}, (parameter) =>\n          applyFormula(parameter.formula, {\n            data,\n            component: ctx.component,\n            formulaCache: ctx.formulaCache,\n            root: ctx.root,\n            package: ctx.package,\n            toddle: ctx.toddle,\n            env: ctx.env,\n          }),\n        )\n\n        if (action.contextProvider) {\n          const provider =\n            ctx.providers[\n              [ctx.package, action.contextProvider].filter(isDefined).join('/')\n            ] ?? ctx.providers[action.contextProvider]\n          const workflow = provider?.component.workflows?.[action.workflow]\n          if (!workflow) {\n            if (provider) {\n              console.warn(\n                `Cannot find workflow \"${action.workflow}\" on component \"${action.contextProvider}\". It has likely been removed or modified.`,\n              )\n            }\n            return\n          }\n\n          workflow.actions.forEach((action) =>\n            handleAction(\n              action,\n              {\n                ...data,\n                ...provider.ctx.dataSignal.get(),\n                Parameters: parameters,\n              },\n              provider.ctx,\n              event,\n            ),\n          )\n          return\n        }\n\n        const workflow = ctx.component.workflows?.[action.workflow]\n        if (!workflow) {\n          console.warn(\n            `Workflow ${action.workflow} does not exist on component ${ctx.component.name}`,\n          )\n          return\n        }\n\n        workflow.actions.forEach((action) =>\n          handleAction(\n            action,\n            {\n              ...data,\n              ...ctx.dataSignal.get(),\n              Parameters: parameters,\n            },\n            ctx,\n            event,\n          ),\n        )\n        break\n      }\n      default: {\n        try {\n          // create a handler for actions triggering events\n          const triggerActionEvent = (trigger: string, eventData: any) => {\n            const subEvent = action.events?.[trigger]\n            if (subEvent) {\n              subEvent.actions.forEach((action) =>\n                handleAction(\n                  action,\n                  eventData\n                    ? { ...data, ...ctx.dataSignal.get(), Event: eventData }\n                    : { ...data, ...ctx.dataSignal.get() },\n                  ctx,\n                  eventData ?? event,\n                ),\n              )\n            }\n          }\n          const newAction =\n            action.version === 2\n              ? (ctx.toddle.getCustomAction ?? ctx.toddle.getCustomAction)(\n                  action.name,\n                  action.package ?? ctx.package,\n                )\n              : undefined\n          if (newAction) {\n            // First evaluate any arguments (input) to the action\n            const args = (action.arguments ?? []).reduce<\n              Record<string, unknown>\n            >(\n              (args, arg) => ({\n                ...args,\n                [arg.name]: applyFormula(arg.formula, {\n                  data,\n                  component: ctx.component,\n                  formulaCache: ctx.formulaCache,\n                  root: ctx.root,\n                  package: ctx.package,\n                  toddle: ctx.toddle,\n                  env: ctx.env,\n                }),\n              }),\n              {},\n            )\n            const result = newAction.handler?.(\n              args,\n              {\n                root: ctx.root,\n                triggerActionEvent,\n              },\n              event,\n            )\n            // If the result is a function, then it should behave as a cleanup function, that runs, usually when the component is unmounted.\n            // Useful for removeEventListeners, clearTimeout, etc.\n            if (\n              result &&\n              (typeof result === 'function' || result instanceof Promise)\n            ) {\n              ctx.dataSignal.subscribe((data) => data, {\n                destroy: () => {\n                  if (result instanceof Promise) {\n                    result\n                      .then((cleanup) => {\n                        if (typeof cleanup === 'function') {\n                          cleanup()\n                        }\n                      })\n                      .catch((err) => console.error(err))\n                  } else {\n                    result()\n                  }\n                },\n              })\n            }\n\n            return result\n          } else {\n            const legacyHandler = ctx.toddle.getAction(action.name)\n            if (!legacyHandler) {\n              console.error('Missing custom action', action.name)\n              return\n            }\n            // First evaluate any arguments (input) to the action\n            const args = action.arguments?.map((arg) =>\n              applyFormula(arg.formula, {\n                data,\n                component: ctx.component,\n                formulaCache: ctx.formulaCache,\n                root: ctx.root,\n                package: ctx.package,\n                toddle: ctx.toddle,\n                env: ctx.env,\n              }),\n            ) ?? [\n              applyFormula(action.data, {\n                data,\n                component: ctx.component,\n                formulaCache: ctx.formulaCache,\n                root: ctx.root,\n                package: ctx.package,\n                toddle: ctx.toddle,\n                env: ctx.env,\n              }),\n            ] // action.data is a fallback to handle an older version of the action spec.\n            return legacyHandler(args, { ...ctx, triggerActionEvent }, event)\n          }\n        } catch (err) {\n          console.error('Error in Custom Action', err)\n        }\n      }\n    }\n  } catch (e) {\n    console.error(e)\n    return null\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-floating-promises */\nimport {\n  createApiEvent,\n  createApiRequest,\n  isApiError,\n  requestHash,\n} from '@toddledev/core/dist/api/api'\nimport type {\n  ApiPerformance,\n  ApiRequest,\n  ApiStatus,\n  ToddleRequestInit,\n} from '@toddledev/core/dist/api/apiTypes'\nimport {\n  isEventStreamHeader,\n  isImageHeader,\n  isJsonHeader,\n  isJsonStreamHeader,\n  isTextHeader,\n} from '@toddledev/core/dist/api/headers'\nimport type { ActionModel } from '@toddledev/core/dist/component/component.types'\nimport type {\n  Formula,\n  FormulaContext,\n  ValueOperationValue,\n} from '@toddledev/core/dist/formula/formula'\nimport { applyFormula } from '@toddledev/core/dist/formula/formula'\nimport type { NestedOmit, RequireFields } from '@toddledev/core/dist/types'\nimport {\n  omitPaths,\n  sortObjectEntries,\n} from '@toddledev/core/dist/utils/collections'\nimport { PROXY_URL_HEADER, validateUrl } from '@toddledev/core/dist/utils/url'\nimport { handleAction } from '../events/handleAction'\nimport type { Signal } from '../signal/signal'\nimport type { ComponentContext, ContextApi } from '../types'\n\n/**\n * Set up an api v2 for a component.\n */\nexport function createAPI(\n  apiRequest: ApiRequest,\n  ctx: ComponentContext,\n): RequireFields<ContextApi, 'update' | 'triggerActions'> {\n  // If `__toddle` isn't found it is in a web component context. We behave as if the page isn't loaded.\n  let timer: any = null\n  let api = { ...apiRequest }\n\n  function constructRequest(api: ApiRequest) {\n    // Get baseUrl and validate it. (It wont be in web component context)\n    let baseUrl: string | undefined = window.origin\n    try {\n      new URL(baseUrl)\n    } catch {\n      baseUrl = undefined\n    }\n\n    return createApiRequest({\n      api,\n      formulaContext: getFormulaContext(api),\n      baseUrl,\n      defaultHeaders: undefined,\n    })\n  }\n\n  // Create the formula context for the api\n  function getFormulaContext(api: ApiRequest): FormulaContext {\n    // Use the general formula context to evaluate the arguments of the api\n    const formulaContext = {\n      data: ctx.dataSignal.get(),\n      component: ctx.component,\n      formulaCache: ctx.formulaCache,\n      root: ctx.root,\n      package: ctx.package,\n      toddle: ctx.toddle,\n      env: ctx.env,\n    }\n\n    // Make sure inputs are also available in the formula context\n    const evaluatedInputs = Object.entries(api.inputs).reduce<\n      Record<string, unknown>\n    >((acc, [key, value]) => {\n      acc[key] = applyFormula(value.formula, formulaContext)\n      return acc\n    }, {})\n\n    const data = {\n      ...formulaContext.data,\n      ApiInputs: {\n        ...evaluatedInputs,\n      },\n    }\n\n    return {\n      component: ctx.component,\n      formulaCache: ctx.formulaCache,\n      root: ctx.root,\n      package: ctx.package,\n      data,\n      toddle: ctx.toddle,\n      env: ctx.env,\n    }\n  }\n\n  function handleRedirectRules(api: ApiRequest) {\n    for (const [ruleName, rule] of sortObjectEntries(\n      api.redirectRules ?? {},\n      ([_, rule]) => rule.index,\n    )) {\n      const location = applyFormula(rule.formula, {\n        ...getFormulaContext(api),\n        data: {\n          ...getFormulaContext(api).data,\n          Apis: {\n            [api.name]: ctx.dataSignal.get().Apis?.[api.name] as ApiStatus,\n          },\n        },\n      })\n      if (typeof location === 'string') {\n        const url = validateUrl(location, window.location.href)\n        if (url) {\n          if (ctx.env.runtime === 'preview') {\n            // Attempt to notify the parent about the failed navigation attempt\n            window.parent?.postMessage(\n              { type: 'blockedNavigation', url: url.href },\n              '*',\n            )\n            return { name: ruleName, index: rule.index, url }\n          } else {\n            window.location.replace(url.href)\n          }\n        }\n      }\n    }\n  }\n\n  function triggerActions(\n    eventName: 'message' | 'success' | 'failed',\n    api: ApiRequest,\n    data: {\n      body: unknown\n      status?: number\n      headers?: Record<string, string>\n    },\n  ) {\n    switch (eventName) {\n      case 'message': {\n        const event = createApiEvent('message', data.body)\n        api.client?.onMessage?.actions?.forEach((action) => {\n          handleAction(\n            action,\n            {\n              ...getFormulaContext(api).data,\n              ...ctx.dataSignal.get(),\n              Event: event,\n            },\n            ctx,\n            event,\n          )\n        })\n        break\n      }\n      case 'success': {\n        const event = createApiEvent('success', data.body)\n        api.client?.onCompleted?.actions?.forEach((action) => {\n          handleAction(\n            action,\n            {\n              ...getFormulaContext(api).data,\n              ...ctx.dataSignal.get(),\n              Event: event,\n            },\n            ctx,\n            event,\n          )\n        })\n        break\n      }\n      case 'failed': {\n        const event = createApiEvent('failed', {\n          error: data.body,\n          status: data.status,\n        })\n        api.client?.onFailed?.actions?.forEach((action) => {\n          handleAction(\n            action,\n            {\n              ...getFormulaContext(api).data,\n              ...ctx.dataSignal.get(),\n              Event: event,\n            },\n            ctx,\n            event,\n          )\n        })\n        break\n      }\n    }\n  }\n\n  function apiSuccess(\n    api: ApiRequest,\n    data: {\n      body: unknown\n      status?: number\n      headers?: Record<string, string>\n    },\n    performance: ApiPerformance,\n  ) {\n    const latestRequestStart =\n      ctx.dataSignal.get().Apis?.[api.name]?.response?.performance?.requestStart\n    if (\n      typeof latestRequestStart === 'number' &&\n      latestRequestStart > (performance.requestStart ?? 0)\n    ) {\n      return\n    }\n\n    ctx.dataSignal.set({\n      ...ctx.dataSignal.get(),\n      Apis: {\n        ...ctx.dataSignal.get().Apis,\n        [api.name]: {\n          isLoading: false,\n          data: data.body,\n          error: null,\n          response: {\n            status: data.status,\n            headers: data.headers,\n            performance,\n          },\n        },\n      },\n    })\n    const appliedRedirectRule = handleRedirectRules(api)\n    if (appliedRedirectRule) {\n      ctx.dataSignal.set({\n        ...ctx.dataSignal.get(),\n        Apis: {\n          ...ctx.dataSignal.get().Apis,\n          [api.name]: {\n            isLoading: false,\n            data: data.body,\n            error: null,\n            response: {\n              status: data.status,\n              headers: data.headers,\n              performance,\n              ...(ctx.env.runtime === 'preview'\n                ? { debug: { appliedRedirectRule } }\n                : {}),\n            },\n          },\n        },\n      })\n    }\n  }\n\n  function apiError(\n    api: ApiRequest,\n    data: {\n      body: unknown\n      status?: number\n      headers?: Record<string, string>\n    },\n    performance: ApiPerformance,\n  ) {\n    const latestRequestStart =\n      ctx.dataSignal.get().Apis?.[api.name]?.response?.performance?.requestStart\n    if (\n      typeof latestRequestStart === 'number' &&\n      latestRequestStart > (performance.requestStart ?? 0)\n    ) {\n      return\n    }\n    ctx.dataSignal.set({\n      ...ctx.dataSignal.get(),\n      Apis: {\n        ...ctx.dataSignal.get().Apis,\n        [api.name]: {\n          isLoading: false,\n          data: null,\n          error: data.body,\n          response: {\n            status: data.status,\n            headers: data.headers,\n            performance,\n          },\n        },\n      },\n    })\n    const appliedRedirectRule = handleRedirectRules(api)\n    if (appliedRedirectRule) {\n      ctx.dataSignal.set({\n        ...ctx.dataSignal.get(),\n        Apis: {\n          ...ctx.dataSignal.get().Apis,\n          [api.name]: {\n            isLoading: false,\n            data: null,\n            error: data.body,\n            response: {\n              status: data.status,\n              headers: data.headers,\n              performance,\n              ...(ctx.env.runtime === 'preview'\n                ? { debug: { appliedRedirectRule } }\n                : {}),\n            },\n          },\n        },\n      })\n    }\n  }\n\n  // Execute the request - potentially to the cloudflare Query proxy\n  async function execute(\n    api: ApiRequest,\n    url: URL,\n    requestSettings: ToddleRequestInit,\n  ) {\n    const run = async () => {\n      const performance: ApiPerformance = {\n        requestStart: Date.now(),\n        responseStart: null,\n        responseEnd: null,\n      }\n      ctx.dataSignal.set({\n        ...ctx.dataSignal.get(),\n        Apis: {\n          ...ctx.dataSignal.get().Apis,\n          [api.name]: {\n            isLoading: true,\n            data: ctx.dataSignal.get().Apis?.[api.name]?.data ?? null,\n            error: null,\n          },\n        },\n      })\n      let response\n\n      try {\n        const proxy = api.server?.proxy\n          ? (applyFormula(\n              api.server.proxy.enabled.formula,\n              getFormulaContext(api),\n            ) ?? false)\n          : false\n\n        if (proxy === false) {\n          response = await fetch(url, requestSettings)\n        } else {\n          const proxyUrl = `/.toddle/omvej/components/${encodeURIComponent(\n            ctx.component.name,\n          )}/apis/${encodeURIComponent(\n            ctx.component.name,\n          )}:${encodeURIComponent(api.name)}`\n          const headers = new Headers(requestSettings.headers)\n          headers.set(\n            PROXY_URL_HEADER,\n            decodeURIComponent(url.href.replace(/\\+/g, ' ')),\n          )\n          requestSettings.headers = headers\n          response = await fetch(proxyUrl, requestSettings)\n        }\n\n        performance.responseStart = Date.now()\n        await handleResponse(api, response, performance)\n        return\n      } catch (error: any) {\n        const body = error.cause\n          ? { message: error.message, data: error.cause }\n          : error.message\n        apiError(api, { body }, { ...performance, responseEnd: Date.now() })\n        triggerActions('failed', api, { body })\n        return Promise.reject(error)\n      }\n    }\n\n    // Debounce the request if needed\n    if (api.client?.debounce?.formula) {\n      return new Promise((resolve, reject) => {\n        if (typeof timer === 'number') {\n          clearTimeout(timer)\n        }\n        timer = setTimeout(\n          () => {\n            run().then(resolve, reject)\n          },\n          applyFormula(api.client?.debounce?.formula, getFormulaContext(api)),\n        )\n      })\n    }\n\n    return run()\n  }\n\n  function handleResponse(\n    api: ApiRequest,\n    res: Response,\n    performance: ApiPerformance,\n  ) {\n    let parserMode = api.client?.parserMode ?? 'auto'\n\n    if (parserMode === 'auto') {\n      const contentType = res.headers.get('content-type')\n      if (isEventStreamHeader(contentType)) {\n        parserMode = 'event-stream'\n      } else if (isJsonHeader(contentType)) {\n        parserMode = 'json'\n      } else if (isTextHeader(contentType)) {\n        parserMode = 'text'\n      } else if (isJsonStreamHeader(contentType)) {\n        parserMode = 'json-stream'\n      } else if (isImageHeader(contentType)) {\n        parserMode = 'blob'\n      } else {\n        parserMode = 'text'\n      }\n    }\n\n    switch (parserMode) {\n      case 'text':\n        return textStreamResponse(api, res, performance)\n      case 'json':\n        return jsonResponse(api, res, performance)\n      case 'event-stream':\n        return eventStreamingResponse(api, res, performance)\n      case 'json-stream':\n        return jsonStreamResponse(api, res, performance)\n      case 'blob':\n        return blobResponse(api, res, performance)\n      default:\n        return textStreamResponse(api, res, performance)\n    }\n  }\n\n  function textStreamResponse(\n    api: ApiRequest,\n    res: Response,\n    performance: ApiPerformance,\n  ) {\n    return handleStreaming({\n      api,\n      res,\n      performance,\n      streamType: 'text',\n      useTextDecoder: true,\n      parseChunk: (chunk) => chunk,\n      parseChunksForData: (chunks) => chunks.join(''),\n    })\n  }\n\n  function jsonStreamResponse(\n    api: ApiRequest,\n    res: Response,\n    performance: ApiPerformance,\n  ) {\n    const parseChunk = (chunk: any) => {\n      let parsedData = chunk\n      try {\n        parsedData = JSON.parse(chunk)\n      } catch {\n        throw new Error('Error occurred while parsing the json chunk.', {\n          cause: parsedData,\n        })\n      }\n      return parsedData\n    }\n\n    return handleStreaming({\n      api,\n      res,\n      performance,\n      streamType: 'json',\n      useTextDecoder: true,\n      parseChunk,\n      parseChunksForData: (chunks) => [...chunks],\n      delimiters: ['\\r\\n', '\\n'],\n    })\n  }\n\n  async function jsonResponse(\n    api: ApiRequest,\n    res: Response,\n    performance: ApiPerformance,\n  ) {\n    const body = await res.json()\n\n    const status: ApiStatus = {\n      data: body,\n      isLoading: false,\n      error: null,\n      response: {\n        status: res.status,\n        headers: Object.fromEntries(res.headers.entries()),\n      },\n    }\n    return endResponse(api, status, performance)\n  }\n\n  async function blobResponse(\n    api: ApiRequest,\n    res: Response,\n    performance: ApiPerformance,\n  ) {\n    const blob = await res.blob()\n\n    const status: ApiStatus = {\n      isLoading: false,\n      data: URL.createObjectURL(blob),\n      error: null,\n      response: {\n        status: res.status,\n        headers: Object.fromEntries(res.headers.entries()),\n      },\n    }\n    return endResponse(api, status, performance)\n  }\n\n  function eventStreamingResponse(\n    api: ApiRequest,\n    res: Response,\n    performance: ApiPerformance,\n  ) {\n    const parseChunk = (chunk: string) => {\n      const event = chunk.match(/event: (.*)/)?.[1] ?? 'message'\n      const data = chunk.match(/data: (.*)/)?.[1] ?? ''\n      const id = chunk.match(/id: (.*)/)?.[1]\n      const retry = chunk.match(/retry: (.*)/)?.[1]\n\n      let parsedData = data\n      try {\n        parsedData = JSON.parse(data ?? '')\n        // eslint-disable-next-line no-empty\n      } catch {}\n      const returnData = {\n        event,\n        data: parsedData,\n        ...(id ? { id } : {}),\n        ...(retry ? { retry } : {}),\n      }\n      return returnData\n    }\n    return handleStreaming({\n      api,\n      res,\n      performance,\n      streamType: 'event',\n      useTextDecoder: true,\n      parseChunk,\n      parseChunksForData: (chunks) => [...chunks],\n      delimiters: ['\\n\\n', '\\r\\n\\r\\n'],\n    })\n  }\n\n  async function handleStreaming({\n    api,\n    res,\n    performance,\n    streamType,\n    useTextDecoder,\n    parseChunk,\n    parseChunksForData,\n    delimiters, // There can be various delimiters for the same stream. SSE might use both \\n\\n and \\r\\n\\r\\n\n  }: {\n    api: ApiRequest\n    res: Response\n    performance: ApiPerformance\n    streamType: 'json' | 'text' | 'event'\n    useTextDecoder: boolean\n    parseChunk: (chunk: any) => any\n    parseChunksForData: (chunks: any[]) => any\n    delimiters?: string[]\n  }) {\n    const chunks: {\n      chunks: any[]\n      currentChunk: string\n      add(chunk: string | Uint8Array): void\n      processChunk(chunk: string | Uint8Array): void\n    } = {\n      chunks: [],\n      currentChunk: '',\n      // Function to add a chunk to the chunks array and emits the data to the onMessage event\n      add(chunk: string | Uint8Array) {\n        const parsedChunk = parseChunk(chunk)\n        this.chunks.push(parsedChunk)\n        // Only emit the data if there are any listeners\n        if (parsedChunk) {\n          ctx.dataSignal.set({\n            ...ctx.dataSignal.get(),\n            Apis: {\n              ...ctx.dataSignal.get().Apis,\n              [api.name]: {\n                isLoading: true,\n                data: parseChunksForData(this.chunks),\n                error: null,\n                response: {\n                  headers: Object.fromEntries(res.headers.entries()),\n                },\n              },\n            },\n          })\n          if ((api.client?.onMessage?.actions ?? []).length > 0) {\n            triggerActions('message', api, { body: parsedChunk })\n          }\n        }\n      },\n\n      // Function to process a chunk and split it by the delimiter.\n      processChunk(chunk: any) {\n        const delimiter = delimiters?.find((d) => chunk.includes(d))\n        const concatenated = this.currentChunk + chunk\n        const split = delimiter ? concatenated.split(delimiter) : [concatenated]\n        this.currentChunk = split.pop() ?? ''\n        split.forEach((c) => this.add(c))\n      },\n    }\n\n    const reader = useTextDecoder\n      ? res.body?.pipeThrough(new TextDecoderStream()).getReader()\n      : res.body?.getReader()\n\n    while (reader) {\n      const { done, value } = await reader.read()\n      if (done) {\n        break\n      }\n\n      if (delimiters) {\n        chunks.processChunk(value)\n      } else {\n        chunks.add(value)\n      }\n    }\n\n    // First make sure theres no remaining chunk\n    if (chunks.currentChunk) {\n      chunks.add(chunks.currentChunk)\n    }\n\n    const status: ApiStatus = {\n      isLoading: false,\n      data: chunks.chunks,\n      error: null,\n      response: {\n        status: res.status,\n        headers: Object.fromEntries(res.headers.entries()),\n      },\n    }\n\n    try {\n      if (streamType === 'json') {\n        const parsed = JSON.parse(chunks.chunks.join(''))\n        status.data = parsed\n      } else if (streamType === 'text') {\n        status.data = chunks.chunks.join('')\n      }\n    } catch {\n      throw new Error('Error occurred while parsing the json chunk.', {\n        cause: chunks.chunks.join(''),\n      })\n    }\n    return endResponse(api, status, performance)\n  }\n\n  function endResponse(\n    api: ApiRequest,\n    apiStatus: ApiStatus,\n    performance: ApiPerformance,\n  ) {\n    performance.responseEnd = Date.now()\n\n    const data = {\n      body: apiStatus.data,\n      status: apiStatus.response?.status,\n      headers: apiStatus.response?.headers ?? undefined,\n    }\n\n    const isError = isApiError({\n      apiName: api.name,\n      response: {\n        body: data.body,\n        ok: Boolean(\n          !apiStatus.error &&\n            apiStatus.response?.status &&\n            apiStatus.response.status < 400,\n        ),\n        status: data.status,\n        headers: data.headers,\n      },\n      formulaContext: getFormulaContext(api),\n      errorFormula: api.isError,\n      performance,\n    })\n\n    if (isError) {\n      if (!data.body && apiStatus.error) {\n        data.body = apiStatus.error\n      }\n\n      apiError(api, data, performance)\n      triggerActions('failed', api, data)\n    } else {\n      apiSuccess(api, data, performance)\n      triggerActions('success', api, data)\n    }\n  }\n\n  function getApiForComparison(api: ApiRequest) {\n    return omitPaths(api, [\n      ['client', 'onCompleted'],\n      ['client', 'onFailed'],\n      ['client', 'onMessage'],\n      ['service'],\n      ['server', 'ssr'],\n    ]) as NestedOmit<\n      ApiRequest,\n      | 'client.onCompleted'\n      | 'client.onFailed'\n      | 'client.onMessage'\n      | 'service'\n      | 'server.ssr'\n    >\n  }\n\n  let payloadSignal:\n    | Signal<{\n        request: ReturnType<typeof constructRequest>\n        api: ReturnType<typeof getApiForComparison>\n        // if the evaluated value of autoFetch changes from false -> true, we need to refetch the api\n        autoFetch: boolean\n        // currently, the proxy setting is always controlled by a \"value formula\", but in case we later\n        // open up for controlling it with a dynamic formula, we should also include it here\n        proxy: boolean\n      }>\n    | undefined\n\n  // eslint-disable-next-line prefer-const\n  payloadSignal = ctx.dataSignal.map((_) => {\n    const payloadContext = getFormulaContext(api)\n    return {\n      request: constructRequest(api),\n      api: getApiForComparison(api),\n      autoFetch: api.autoFetch\n        ? applyFormula(api.autoFetch, payloadContext)\n        : false,\n      proxy: applyFormula(api.server?.proxy?.enabled.formula, payloadContext),\n    }\n  })\n  payloadSignal.subscribe(async (_) => {\n    if (api.autoFetch && applyFormula(api.autoFetch, getFormulaContext(api))) {\n      // Ensure we only use caching if the page is currently loading\n      if ((window?.__toddle?.isPageLoaded ?? false) === false) {\n        const { url, requestSettings } = constructRequest(api)\n        const cacheKey = requestHash(url, requestSettings)\n        const cacheMatch = ctx.toddle.pageState.Apis?.[cacheKey] as ApiStatus\n        if (cacheMatch) {\n          if (cacheMatch.error) {\n            apiError(\n              api,\n              {\n                body: cacheMatch.error,\n                status: cacheMatch.response?.status,\n                headers: cacheMatch.response?.headers ?? undefined,\n              },\n              {\n                requestStart:\n                  cacheMatch.response?.performance?.requestStart ?? null,\n                responseStart:\n                  cacheMatch.response?.performance?.responseStart ?? null,\n                responseEnd:\n                  cacheMatch.response?.performance?.responseEnd ?? null,\n              },\n            )\n          } else {\n            apiSuccess(\n              api,\n              {\n                body: cacheMatch.data,\n                status: cacheMatch.response?.status,\n                headers: cacheMatch.response?.headers ?? undefined,\n              },\n              {\n                requestStart:\n                  cacheMatch.response?.performance?.requestStart ?? null,\n                responseStart:\n                  cacheMatch.response?.performance?.responseStart ?? null,\n                responseEnd:\n                  cacheMatch.response?.performance?.responseEnd ?? null,\n              },\n            )\n          }\n        } else {\n          // Execute will set the initial status of the api in the dataSignal\n          await execute(api, url, requestSettings)\n        }\n      } else {\n        // Execute will set the initial status of the api in the dataSignal\n        const { url, requestSettings } = constructRequest(api)\n        await execute(api, url, requestSettings)\n      }\n    } else {\n      ctx.dataSignal.update((data) => {\n        return {\n          ...data,\n          Apis: {\n            ...(data.Apis ?? {}),\n            [api.name]: {\n              isLoading: false,\n              data: null,\n              error: null,\n            },\n          },\n        }\n      })\n    }\n  })\n\n  return {\n    fetch: ({\n      actionInputs,\n      actionModels,\n    }: {\n      actionInputs?: Record<\n        string,\n        | ValueOperationValue\n        | {\n            name: string\n            formula?: Formula\n          }\n      >\n      actionModels?: {\n        onCompleted: ActionModel[]\n        onFailed: ActionModel[]\n        onMessage: ActionModel[]\n      }\n    }) => {\n      // Inputs might already be evaluated. If they are we add them as a value formula to be evaluated later.\n      const inputs = Object.entries(actionInputs ?? {}).reduce<\n        Record<\n          string,\n          {\n            formula: Formula\n          }\n        >\n      >((acc, [inputName, input]) => {\n        if (input !== null && typeof input === 'object' && 'formula' in input) {\n          acc[inputName] = input as {\n            formula: Formula\n          }\n        } else {\n          acc[inputName] = {\n            formula: { type: 'value', value: input },\n          }\n        }\n        return acc\n      }, {})\n\n      const apiWithInputsAndActions: ApiRequest = {\n        ...api,\n        inputs: { ...api.inputs, ...inputs },\n        client: {\n          ...api.client,\n          parserMode: api.client?.parserMode ?? 'auto',\n          onCompleted: {\n            trigger: api.client?.onCompleted?.trigger ?? 'success',\n            actions: [\n              ...(api.client?.onCompleted?.actions ?? []),\n              ...(actionModels?.onCompleted ?? []),\n            ],\n          },\n          onFailed: {\n            trigger: api.client?.onFailed?.trigger ?? 'failed',\n            actions: [\n              ...(api.client?.onFailed?.actions ?? []),\n              ...(actionModels?.onFailed ?? []),\n            ],\n          },\n          onMessage: {\n            trigger: api.client?.onMessage?.trigger ?? 'message',\n            actions: [\n              ...(api.client?.onMessage?.actions ?? []),\n              ...(actionModels?.onMessage ?? []),\n            ],\n          },\n        },\n      }\n\n      const { url, requestSettings } = constructRequest(apiWithInputsAndActions)\n\n      return execute(apiWithInputsAndActions, url, requestSettings)\n    },\n    update: (newApi: ApiRequest) => {\n      api = newApi\n      const updateContext = getFormulaContext(api)\n      const autoFetch =\n        api.autoFetch && applyFormula(api.autoFetch, updateContext)\n      if (autoFetch) {\n        payloadSignal?.set({\n          request: constructRequest(newApi),\n          api: getApiForComparison(newApi),\n          autoFetch,\n          proxy: applyFormula(\n            newApi.server?.proxy?.enabled.formula,\n            updateContext,\n          ),\n        })\n      }\n    },\n    triggerActions: () => {\n      const apiData = ctx.dataSignal.get().Apis?.[api.name]\n      if (\n        apiData === undefined ||\n        (apiData.data === null && apiData.error === null)\n      ) {\n        return\n      }\n      if (apiData.error) {\n        triggerActions('failed', api, {\n          body: apiData.error,\n          status: apiData.response?.status,\n        })\n      } else {\n        triggerActions('success', api, {\n          body: apiData.data,\n        })\n      }\n    },\n    destroy: () => payloadSignal?.destroy(),\n  }\n}\n", "import type {\n  Component,\n  ComponentData,\n} from '@toddledev/core/dist/component/component.types'\nimport type { ToddleEnv } from '@toddledev/core/dist/formula/formula'\nimport type { Toddle } from '@toddledev/core/dist/types'\nimport deepEqual from 'fast-deep-equal'\nimport { handleAction } from '../events/handleAction'\nimport type { Signal } from '../signal/signal'\nimport type {\n  ComponentChild,\n  ComponentContext,\n  FormulaCache,\n  LocationSignal,\n  PreviewShowSignal,\n  SupportedNamespaces,\n} from '../types'\nimport { BatchQueue } from '../utils/BatchQueue'\nimport { createNode } from './createNode'\n\ninterface RenderComponentProps {\n  component: Component\n  components: Component[]\n  dataSignal: Signal<ComponentData>\n  apis: Record<string, { fetch: Function; destroy: Function }>\n  abortSignal: AbortSignal\n  onEvent: (event: string, data: unknown) => void\n  isRootComponent: boolean\n  formulaCache: FormulaCache\n  path: string\n  children: Record<string, Array<ComponentChild>>\n  root: Document | ShadowRoot\n  providers: Record<\n    string,\n    {\n      component: Component\n      formulaDataSignals: Record<string, Signal<ComponentData>>\n      ctx: ComponentContext\n    }\n  >\n  package: string | undefined\n  parentElement: Element | ShadowRoot\n  instance: Record<string, string>\n  toddle: Toddle<LocationSignal, PreviewShowSignal>\n  namespace?: SupportedNamespaces\n  env: ToddleEnv\n}\n\nconst BATCH_QUEUE = new BatchQueue()\n\nexport function renderComponent({\n  component,\n  dataSignal,\n  onEvent,\n  isRootComponent,\n  path,\n  children,\n  formulaCache,\n  components,\n  apis,\n  abortSignal,\n  root,\n  providers,\n  package: packageName,\n  parentElement,\n  instance,\n  toddle,\n  namespace,\n  env,\n}: RenderComponentProps): ReadonlyArray<Element | Text> {\n  const ctx: ComponentContext = {\n    triggerEvent: onEvent,\n    component,\n    components,\n    dataSignal,\n    isRootComponent,\n    apis,\n    formulaCache,\n    children,\n    abortSignal,\n    root,\n    providers,\n    package: packageName,\n    toddle,\n    env,\n  }\n\n  const rootElem = createNode({\n    id: 'root',\n    path,\n    dataSignal,\n    ctx,\n    parentElement,\n    namespace,\n    instance,\n  })\n  BATCH_QUEUE.add(() => {\n    let prev: Record<string, any> | undefined\n    if (\n      component.onAttributeChange?.actions &&\n      component.onAttributeChange.actions.length > 0\n    ) {\n      dataSignal\n        .map((data) => data.Attributes)\n        .subscribe((props) => {\n          if (prev) {\n            component.onAttributeChange?.actions.forEach((action) => {\n              // eslint-disable-next-line @typescript-eslint/no-floating-promises\n              handleAction(\n                action,\n                dataSignal.get(),\n                ctx,\n                new CustomEvent('attribute-change', {\n                  detail: Object.entries(props).reduce(\n                    (\n                      changes: Record<string, { current: any; new: any }>,\n                      [key, value],\n                    ) => {\n                      if (\n                        deepEqual(value, prev![key]) === false &&\n                        component.attributes[key]?.name\n                      ) {\n                        changes[component.attributes[key]?.name] = {\n                          current: prev![key],\n                          new: value,\n                        }\n                      }\n                      return changes\n                    },\n                    {},\n                  ),\n                }),\n              )\n            })\n          }\n          prev = props\n        })\n    }\n    component.onLoad?.actions.forEach((action) => {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      handleAction(action, dataSignal.get(), ctx)\n    })\n  })\n  return rootElem\n}\n", "/**\n * A helper class to batch multiple callbacks and process them in a single update step just before the next frame render, but after the current stack.\n * This is more efficient than processing each callback in a separate requestAnimationFrame due to the overhead.\n */\nexport class BatchQueue {\n  private batchQueue: Array<() => void> = []\n  private isProcessing = false\n  private processBatch() {\n    if (this.isProcessing) return\n    this.isProcessing = true\n\n    requestAnimationFrame(() => {\n      while (this.batchQueue.length > 0) {\n        const callback = this.batchQueue.shift()\n        callback?.()\n      }\n      this.isProcessing = false\n    })\n  }\n  public add(callback: () => void) {\n    this.batchQueue.push(callback)\n    this.processBatch()\n  }\n}\n", "import type {\n  ComponentData,\n  NodeModel,\n} from '@toddledev/core/dist/component/component.types'\nimport { applyFormula } from '@toddledev/core/dist/formula/formula'\nimport { toBoolean } from '@toddledev/core/dist/utils/util'\nimport type { Signal } from '../signal/signal'\nimport { signal } from '../signal/signal'\nimport type { ComponentContext, SupportedNamespaces } from '../types'\nimport { ensureEfficientOrdering, getNextSiblingElement } from '../utils/nodes'\nimport { createComponent } from './createComponent'\nimport { createElement } from './createElement'\nimport { createSlot } from './createSlot'\nimport { createText } from './createText'\n\nexport function createNode({\n  id,\n  dataSignal,\n  path,\n  ctx,\n  namespace,\n  parentElement,\n  instance,\n}: {\n  id: string\n  dataSignal: Signal<ComponentData>\n  path: string\n  ctx: ComponentContext\n  namespace?: SupportedNamespaces\n  parentElement: Element | ShadowRoot\n  instance: Record<string, string>\n}): ReadonlyArray<Element | Text> {\n  const node = ctx.component.nodes[id]\n  if (!node) {\n    return []\n  }\n  const create = ({\n    node,\n    ...props\n  }: NodeRenderer<NodeModel>): ReadonlyArray<Element | Text> => {\n    switch (node.type) {\n      case 'element':\n        return [\n          createElement({\n            node,\n            ...props,\n          }),\n        ]\n      case 'component':\n        // eslint-disable-next-line no-case-declarations\n        const isLocalComponent = ctx.components.some(\n          (c) => c.name === node.name,\n        )\n        return createComponent({\n          node: { ...node, id }, // we need the node id for instance classes\n          ...props,\n          ctx: {\n            ...ctx,\n            package:\n              node.package ?? (isLocalComponent ? undefined : ctx.package),\n          },\n          parentElement,\n        })\n      case 'text':\n        return [createText({ ...props, node })]\n      case 'slot':\n        return createSlot({ ...props, node })\n    }\n  }\n\n  function conditional({\n    node,\n    dataSignal,\n    id,\n    path,\n    ctx,\n    namespace,\n    parentElement,\n    instance,\n  }: NodeRenderer<NodeModel>): ReadonlyArray<Element | Text> {\n    let firstRun = true\n    let childDataSignal: Signal<ComponentData> | null = null\n    const showSignal = dataSignal.map((data) =>\n      toBoolean(\n        applyFormula(node.condition, {\n          data,\n          component: ctx.component,\n          formulaCache: ctx.formulaCache,\n          root: ctx.root,\n          package: ctx.package,\n          toddle: ctx.toddle,\n          env: ctx.env,\n        }),\n      ),\n    )\n\n    const elements: Array<Element | Text> = []\n    const toggle = (show: boolean) => {\n      if (show && elements.length === 0) {\n        childDataSignal?.destroy()\n        childDataSignal = dataSignal.map((data) => data)\n        elements.push(\n          ...create({\n            node,\n            dataSignal: childDataSignal,\n            path,\n            id,\n            ctx,\n            namespace,\n            parentElement,\n            instance,\n          }),\n        )\n\n        // No reason to continue if we are on first run, as the render phase has not yet been reached\n        if (firstRun) {\n          return\n        }\n\n        if (!parentElement || ctx.root.contains(parentElement) === false) {\n          console.error(\n            `Conditional: Parent element does not exist for \"${path}\" This is likely due to the DOM being modified outside of toddle.`,\n          )\n          return\n        }\n\n        if (parentElement.querySelector(`[data-id=\"${path}\"]`)) {\n          console.warn(\n            `Conditional: Element with data-id=\"${path}\" already exists. This is likely due to the DOM being modified outside of toddle`,\n          )\n          return\n        }\n\n        const nextPathElement = getNextSiblingElement(path, parentElement)\n        for (const element of elements) {\n          parentElement.insertBefore(element, nextPathElement)\n        }\n      } else if (!show) {\n        childDataSignal?.destroy()\n        elements.forEach((elem) => elem.remove())\n        elements.splice(0, elements.length)\n      }\n    }\n\n    showSignal.subscribe(toggle, {\n      destroy: () => {\n        childDataSignal?.destroy()\n      },\n    })\n    if (ctx.env.runtime === 'preview' && ctx.toddle._preview) {\n      ctx.toddle._preview.showSignal.subscribe(\n        ({ displayedNodes, testMode }) => {\n          if (displayedNodes.includes(path) && !testMode) {\n            // only override the default show if we are in design mode (not test mode)\n            toggle(true)\n          } else {\n            toggle(showSignal.get())\n          }\n        },\n      )\n    }\n\n    firstRun = false\n    return elements\n  }\n\n  function repeat(): ReadonlyArray<Element | Text> {\n    let firstRun = true\n    let repeatItems = new Map<\n      string | number,\n      {\n        dataSignal: Signal<ComponentData>\n        cleanup: () => void\n        elements: ReadonlyArray<Element | Text>\n      }\n    >()\n    const repeatSignal = dataSignal.map((data) => {\n      const list = applyFormula(node.repeat, {\n        data,\n        component: ctx.component,\n        formulaCache: ctx.formulaCache,\n        root: ctx.root,\n        package: ctx.package,\n        toddle: ctx.toddle,\n        env: ctx.env,\n      })\n      if (typeof list !== 'object') {\n        return []\n      }\n      return Object.entries(list ?? {})\n    })\n\n    repeatSignal.subscribe(\n      (list) => {\n        const newRepeatItems = new Map<\n          string | number,\n          {\n            dataSignal: Signal<ComponentData>\n            cleanup: () => void\n            elements: ReadonlyArray<Element | Text>\n          }\n        >()\n\n        for (let i = 0; i < list.length; i++) {\n          const [Key, Item] = list[i]\n          const childData = {\n            ...dataSignal.get(),\n            ListItem: {\n              ...(dataSignal.get().ListItem\n                ? { Parent: dataSignal.get().ListItem }\n                : {}),\n              Item,\n              Index: Number(i),\n              Key,\n            },\n          }\n\n          let childKey = node.repeatKey\n            ? applyFormula(node.repeatKey, {\n                data: childData,\n                component: ctx.component,\n                formulaCache: ctx.formulaCache,\n                root: ctx.root,\n                package: ctx.package,\n                toddle: ctx.toddle,\n                env: ctx.env,\n              })\n            : Key\n\n          // Can't we just use the Item reference as key as we have fine-grained reactivity at this point?\n          // That way we won't need repeatKey at all as everything will be optimized by reference?!?\n          // https://github.com/solidjs/solid/discussions/366#discussioncomment-1220239\n          // childKey = Item\n          // Do fallback to Key(index) if repeatKey has duplicate values.\n          // This will essentially disable the optimization for repeatKey and will always re-render the children on every change.\n          if (newRepeatItems.has(childKey)) {\n            console.warn(\n              `Duplicate key \"${childKey}\" found in repeat. Fallback to index as key. This will cause a re-render of the duplicated children on every change.`,\n            )\n            childKey = Key\n          }\n\n          const existingItem = repeatItems.get(childKey)\n          if (existingItem) {\n            newRepeatItems.set(childKey, existingItem)\n            existingItem.dataSignal.update((data) => {\n              return {\n                ...data,\n                ListItem: {\n                  ...(dataSignal.get().ListItem\n                    ? { Parent: dataSignal.get().ListItem }\n                    : {}),\n                  Item,\n                  Index: Number(i),\n                  Key,\n                },\n              }\n            })\n          } else {\n            const childDataSignal = signal<ComponentData>(childData)\n            const cleanup = dataSignal.subscribe(\n              (data) => {\n                if (firstRun) {\n                  return\n                }\n\n                childDataSignal.update(({ ListItem }) => {\n                  return {\n                    ...data,\n                    ListItem,\n                  }\n                })\n              },\n              {\n                destroy: () => childDataSignal.destroy(),\n              },\n            )\n\n            const args = {\n              node,\n              id,\n              dataSignal: childDataSignal,\n              path: Key === '0' ? path : `${path}(${Key})`,\n              ctx,\n              namespace,\n              parentElement,\n              instance,\n            }\n            const elements = node.condition ? conditional(args) : create(args)\n            newRepeatItems.set(childKey, {\n              dataSignal: childDataSignal,\n              cleanup,\n              elements,\n            })\n          }\n        }\n\n        // Cleanup removed items' data\n        Array.from(repeatItems.entries()).forEach(([key, item]) => {\n          if (!newRepeatItems.has(key)) {\n            item.cleanup()\n            item.dataSignal.destroy()\n            item.elements.forEach((e) => e.remove())\n          }\n        })\n        repeatItems = newRepeatItems\n\n        // No reason to continue if we are on first run, as the render-phase for the parent\n        // has not yet been reached, or if there are no items to render\n        if (firstRun || repeatItems.size === 0) {\n          return\n        }\n\n        if (!parentElement || ctx.root.contains(parentElement) === false) {\n          console.error(\n            `Repeat: Parent element does not exist for ${path}. This is likely due to the DOM being modified outside of toddle.`,\n          )\n          return\n        }\n\n        ensureEfficientOrdering(\n          parentElement,\n          Array.from(repeatItems.values()).flatMap((e) => e.elements),\n          getNextSiblingElement(path, parentElement),\n        )\n      },\n      {\n        destroy: () =>\n          Array.from(repeatItems.values()).forEach((e) => {\n            e.cleanup()\n            e.dataSignal.destroy()\n            e.elements.forEach((e) => e.remove())\n          }),\n      },\n    )\n\n    // We utilize that the signal subscription runs synchronously above,\n    // so we already have a populated repeatItems map to return initially.\n    // Note: `repeatItems.values()` is okay here, as maps' iterator is ordered by insertion.\n    firstRun = false\n    return Array.from(repeatItems.values()).flatMap((e) => e.elements)\n  }\n\n  if (node.repeat) {\n    return repeat()\n  }\n  if (node.condition) {\n    return conditional({\n      node,\n      dataSignal,\n      ctx,\n      id,\n      path,\n      namespace,\n      parentElement,\n      instance,\n    })\n  }\n  return create({\n    node,\n    dataSignal,\n    ctx,\n    id,\n    path,\n    namespace,\n    parentElement,\n    instance,\n  })\n}\nexport type NodeRenderer<NodeType> = {\n  node: NodeType\n  dataSignal: Signal<ComponentData>\n  id: string\n  path: string\n  ctx: ComponentContext\n  namespace?: SupportedNamespaces\n  parentElement: Element | ShadowRoot\n  instance: Record<string, string>\n}\n", "import deepEqual from 'fast-deep-equal'\n\nexport class Signal<T> {\n  value: T\n  subscribers: Set<{\n    notify: (value: T) => void\n    destroy?: () => void\n  }>\n  subscriptions: Array<() => void>\n\n  constructor(value: T) {\n    this.value = value\n    this.subscribers = new Set()\n    this.subscriptions = []\n  }\n  get() {\n    return this.value\n  }\n  set(value: T) {\n    // Short circuit and skip expensive `deepEqual` if there are not currently any subscribers\n    if (this.subscribers.size === 0) {\n      this.value = value\n      return\n    }\n\n    if (deepEqual(value, this.value) === false) {\n      this.value = value\n      this.subscribers.forEach(({ notify }) => notify(this.value))\n    }\n  }\n\n  update(f: (current: T) => T) {\n    this.set(f(this.value))\n  }\n  subscribe(notify: (value: T) => void, config?: { destroy?: () => void }) {\n    const subscriber = { notify, destroy: config?.destroy }\n    this.subscribers.add(subscriber)\n    notify(this.value)\n    return () => {\n      this.subscribers.delete(subscriber)\n    }\n  }\n  destroy() {\n    this.subscribers.forEach(({ destroy }) => {\n      destroy?.()\n    })\n    this.subscribers.clear()\n    this.subscriptions?.forEach((f) => f())\n  }\n  cleanSubscribers() {\n    this.subscribers.forEach(({ destroy }) => {\n      destroy?.()\n    })\n    this.subscribers.clear()\n  }\n  map<T2>(f: (value: T) => T2): Signal<T2> {\n    const signal2 = signal(f(this.value))\n    signal2.subscriptions.push(\n      this.subscribe((value) => signal2.set(f(value)), {\n        destroy: () => signal2.destroy(),\n      }),\n    )\n    return signal2\n  }\n}\n\nexport function signal<T>(value: T) {\n  return new Signal(value)\n}\n\nif (typeof window !== 'undefined') {\n  ;(window as any).signal = signal\n  ;(window as any).deepEqual = deepEqual\n}\n", "import type {\n  Component,\n  NodeModel,\n} from '@toddledev/core/dist/component/component.types'\n\ntype NodeWithNodeId = NodeModel & { nodeId: string }\n\ninterface NodeAndAncestorLookup {\n  node: NodeWithNodeId\n  ancestors: NodeWithNodeId[]\n}\n\nexport const getNodeAndAncestors = (\n  component: Component,\n  root: NodeModel,\n  id: unknown,\n): NodeAndAncestorLookup | undefined => {\n  if (typeof id !== 'string' || id.length === 0) {\n    return undefined\n  }\n  const path = id.split('.')\n  const pathParsed = path.map((n) => parseInt(n))\n  const ancestors: NodeWithNodeId[] = []\n  // nodePath skips the root element as it's selected as the initial\n  // value in the reduce below\n  const nodePath = pathParsed.slice(1)\n  const node = nodePath.reduce((node: NodeModel | undefined, childIndex, i) => {\n    switch (node?.type) {\n      // 'text' elements don't have any children\n      case 'element':\n      case 'component':\n      case 'slot':\n        // Ancestors are elements before the target node\n        if (i <= nodePath.length - 1) {\n          ancestors.push({\n            ...node,\n            // Use the original path as origin to get correct nodeIds\n            nodeId: path.slice(0, i + 1).join('.'),\n          })\n        }\n        return component.nodes[node.children[childIndex]]\n      default:\n        return undefined\n    }\n  }, root)\n  if (node === undefined) {\n    return undefined\n  }\n  return { node: { ...node, nodeId: id }, ancestors }\n}\n\nexport const isNodeOrAncestorConditional = (\n  nodeLookup?: NodeAndAncestorLookup,\n): nodeLookup is NodeAndAncestorLookup =>\n  nodeLookup?.node?.condition !== undefined ||\n  nodeLookup?.ancestors.some((a) => a.condition !== undefined) === true\n\n/**\n * @returns The next toddle sibling element or null if this is the last element. A toddle sibling is a sibling with a higher index or a the index, but a higher repeat index.\n */\nexport const getNextSiblingElement = (\n  path: string,\n  parentElement: Element | ShadowRoot,\n) => {\n  const pathParts = path.split('.')\n  const lastPathPart = pathParts.slice(-1)[0]\n  const index = parseInt(lastPathPart)\n  const repeatIndex = parseInt(String(lastPathPart.split('(')[1]))\n\n  // Find the first child that either has a higher index or a similar index, but higher repeat index\n  for (const child of parentElement.children) {\n    const childPath = child.getAttribute('data-id')\n    const lastChildPathPart = childPath?.split('.').slice(-1)[0]\n    const childIndex = parseInt(String(lastChildPathPart))\n    if (\n      childIndex === index &&\n      parseInt(String(lastChildPathPart?.split('(')[1])) > repeatIndex\n    ) {\n      return child\n    }\n\n    if (childIndex > index) {\n      return child\n    }\n  }\n\n  return null\n}\n\n/**\n * This function efficiently ensures that:\n * 1. New items are added in the correct position.\n * 2. Existing items are not moved if they are already in the correct order.\n */\nexport function ensureEfficientOrdering(\n  parentElement: Element | ShadowRoot,\n  items: ReadonlyArray<Element | Text>,\n  nextElement: Element | Text | null = null,\n) {\n  // Identify the starting point for comparisons.\n  let insertBeforeElement = nextElement // If insertBeforeElement is null, items will be appended at the end.\n\n  // To track the current position in the DOM, we'll use a marker that advances through the sibling elements.\n  let currentMarker = insertBeforeElement\n    ? insertBeforeElement.previousSibling\n    : parentElement.lastChild\n\n  // We'll process the items array in reverse order to minimize the number of DOM operations.\n  for (let i = items.length - 1; i >= 0; i--) {\n    const item = items[i]\n\n    // Check if the item is already in the correct position by comparing it with the currentMarker.\n    if (item === currentMarker) {\n      // The item is in the correct position, move the marker to the previous sibling.\n      currentMarker = item.previousSibling\n    } else {\n      // The item is either not in the DOM or not in the correct position.\n      // Insert the item before the insertBeforeElement (or append it if insertBeforeElement is null).\n      parentElement.insertBefore(item, insertBeforeElement)\n    }\n\n    // Update insertBeforeElement to the current item for the next iteration, as we need to insert subsequent items before this one.\n    insertBeforeElement = item\n  }\n}\n", "import { isLegacyApi, sortApiObjects } from '@toddledev/core/dist/api/api'\nimport type {\n  ComponentData,\n  ComponentNodeModel,\n} from '@toddledev/core/dist/component/component.types'\nimport { applyFormula } from '@toddledev/core/dist/formula/formula'\nimport type { RequireFields } from '@toddledev/core/dist/types'\nimport { mapObject } from '@toddledev/core/dist/utils/collections'\nimport { isDefined } from '@toddledev/core/dist/utils/util'\nimport { createLegacyAPI } from '../api/createAPI'\nimport { createAPI } from '../api/createAPIv2'\nimport { isContextProvider } from '../context/isContextProvider'\nimport { subscribeToContext } from '../context/subscribeToContext'\nimport { registerComponentToLogState } from '../debug/logState'\nimport { handleAction } from '../events/handleAction'\nimport type { Signal } from '../signal/signal'\nimport { signal } from '../signal/signal'\nimport type {\n  ComponentChild,\n  ComponentContext,\n  ContextApi,\n  SupportedNamespaces,\n} from '../types'\nimport { createFormulaCache } from '../utils/createFormulaCache'\nimport { renderComponent } from './renderComponent'\n\nexport type RenderComponentNodeProps = {\n  path: string\n  node: ComponentNodeModel\n  dataSignal: Signal<ComponentData>\n  ctx: ComponentContext\n  parentElement: Element | ShadowRoot\n  instance: Record<string, string>\n  namespace?: SupportedNamespaces\n}\n\nexport function createComponent({\n  node,\n  path,\n  dataSignal,\n  ctx,\n  parentElement,\n  instance,\n  namespace,\n}: RenderComponentNodeProps): ReadonlyArray<Element | Text> {\n  const nodeLookupKey = [ctx.package, node.name].filter(isDefined).join('/')\n  const component = ctx.components?.find((comp) => comp.name === nodeLookupKey)\n  if (!component) {\n    console.warn(\n      `Could not find component \"${nodeLookupKey}\" for component \"${\n        ctx.component.name\n      }\". Available components are: [\"${ctx.components\n        .map((c) => c.name)\n        .join('\", \"')}\"]`,\n    )\n    return []\n  }\n  const attributesSignal = dataSignal.map((data) => {\n    return mapObject(node.attrs, ([attr, value]) => [\n      attr,\n      value?.type !== 'value'\n        ? applyFormula(value, {\n            data,\n            component: ctx.component,\n            formulaCache: ctx.formulaCache,\n            root: ctx.root,\n            package: ctx.package,\n            toddle: ctx.toddle,\n            env: ctx.env,\n          })\n        : value?.value,\n    ])\n  })\n\n  const componentDataSignal = signal<ComponentData>({\n    Location: dataSignal.get().Location,\n    Attributes: attributesSignal.get(),\n    Apis: mapObject(component.apis, ([name, api]) => [\n      name,\n      {\n        data: null,\n        isLoading:\n          api.autoFetch &&\n          applyFormula(api.autoFetch, {\n            data: dataSignal.get(),\n            component,\n            formulaCache: ctx.formulaCache,\n            root: ctx.root,\n            package: ctx.package,\n            toddle: ctx.toddle,\n            env: ctx.env,\n          })\n            ? true\n            : false,\n        error: null,\n      },\n    ]),\n  })\n  // Subscribe context before calculating variable initial values to ensure they can reference context values\n  subscribeToContext(componentDataSignal, component, ctx)\n  componentDataSignal.update((data) => ({\n    ...data,\n    Variables: mapObject(component.variables, ([name, variable]) => [\n      name,\n      applyFormula(variable.initialValue, {\n        // Initial value\n        data: componentDataSignal.get(),\n        component,\n        formulaCache: ctx.formulaCache,\n        root: ctx.root,\n        package: ctx.package,\n        toddle: ctx.toddle,\n        env: ctx.env,\n      }),\n    ]),\n  }))\n  registerComponentToLogState(component, componentDataSignal)\n\n  // Call the abort signal if the component's datasignal is destroyed (component unmounted) to cancel any pending requests\n  const abortController = new AbortController()\n  componentDataSignal.subscribe(() => {}, {\n    destroy: () =>\n      abortController.abort(`Component ${component.name} unmounted`),\n  })\n  const formulaCache = createFormulaCache(component)\n\n  // Note: this function must run procedurally to ensure apis (which are in correct order) can reference each other\n  const apis: Record<string, ContextApi> = {}\n  sortApiObjects(Object.entries(component.apis)).forEach(([name, api]) => {\n    if (isLegacyApi(api)) {\n      apis[name] = createLegacyAPI(api, {\n        ...ctx,\n        apis,\n        component,\n        dataSignal: componentDataSignal,\n        abortSignal: abortController.signal,\n        isRootComponent: false,\n        formulaCache,\n        package: node.package ?? ctx.package,\n        triggerEvent: (eventTrigger, data) => {\n          const eventHandler = Object.values(node.events).find(\n            (e) => e.trigger === eventTrigger,\n          )\n          if (eventHandler) {\n            eventHandler.actions.forEach((action) =>\n              handleAction(action, { ...dataSignal.get(), Event: data }, ctx),\n            )\n          }\n        },\n      })\n    } else {\n      apis[name] = createAPI(api, {\n        ...ctx,\n        apis,\n        component,\n        dataSignal: componentDataSignal,\n        abortSignal: abortController.signal,\n        isRootComponent: false,\n        formulaCache,\n        package: node.package ?? ctx.package,\n        triggerEvent: (eventTrigger, data) => {\n          const eventHandler = Object.values(node.events).find(\n            (e) => e.trigger === eventTrigger,\n          )\n          if (eventHandler) {\n            eventHandler.actions.forEach((action) =>\n              handleAction(action, { ...dataSignal.get(), Event: data }, ctx),\n            )\n          }\n        },\n      })\n    }\n  })\n  Object.values(apis)\n    .filter(\n      (api): api is RequireFields<ContextApi, 'triggerActions'> =>\n        api.triggerActions !== undefined,\n    )\n    .forEach((api) => {\n      api.triggerActions()\n    })\n\n  const onEvent = (eventTrigger: string, data: any) => {\n    const eventHandler = Object.values(node.events).find(\n      (e) => e.trigger === eventTrigger,\n    )\n    if (eventHandler) {\n      eventHandler.actions.forEach((action) =>\n        handleAction(action, { ...dataSignal.get(), Event: data }, ctx),\n      )\n    }\n  }\n\n  let providers = ctx.providers\n  if (isContextProvider(component)) {\n    // Subscribe to exposed formulas and update the component's data signal\n    const formulaDataSignals = Object.fromEntries(\n      Object.entries(component.formulas ?? {})\n        .filter(([, formula]) => formula.exposeInContext)\n        .map(([name, formula]) => [\n          name,\n          componentDataSignal.map((data) =>\n            applyFormula(formula.formula, {\n              data,\n              component,\n              formulaCache: ctx.formulaCache,\n              root: ctx.root,\n              package: ctx.package,\n              toddle: ctx.toddle,\n              env: ctx.env,\n            }),\n          ),\n        ]),\n    )\n\n    providers = {\n      ...providers,\n      [component.name]: {\n        component,\n        formulaDataSignals,\n        ctx: {\n          ...ctx,\n          apis,\n          component,\n          dataSignal: componentDataSignal,\n          abortSignal: abortController.signal,\n          triggerEvent: onEvent,\n        },\n      },\n    }\n  }\n\n  const children: Record<string, Array<ComponentChild>> = {}\n  for (let i = 0; i < node.children.length; i++) {\n    const childId = node.children[i]\n    const childNode = ctx.component.nodes[childId]\n    const slotName = childNode.slot ?? 'default'\n    children[slotName] = children[slotName] ?? []\n    children[slotName].push({\n      id: childId,\n      path: `${path}.${i}[${slotName}]`,\n      dataSignal,\n      ctx: {\n        ...ctx,\n        package: node.package ?? ctx.package,\n      },\n    })\n  }\n\n  attributesSignal.subscribe(\n    (Attributes) =>\n      componentDataSignal.update((data) => ({\n        ...data,\n        Attributes,\n      })),\n    { destroy: () => componentDataSignal.destroy() },\n  )\n\n  return renderComponent({\n    dataSignal: componentDataSignal,\n    component,\n    components: ctx.components,\n    path,\n    root: ctx.root,\n    isRootComponent: false,\n    children,\n    formulaCache,\n    providers,\n    apis,\n    abortSignal: abortController.signal,\n    package: node.package ?? ctx.package,\n    parentElement,\n    onEvent,\n    toddle: ctx.toddle,\n    env: ctx.env,\n    namespace,\n    // If the root node is another component, then append and forward previous instance\n    instance:\n      node.id === 'root'\n        ? { ...instance, [ctx.component.name]: 'root' }\n        : { [ctx.component.name]: node.id ?? '' },\n  })\n}\n", "/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */\nimport type { Component } from '@toddledev/core/dist/component/component.types'\n\nexport const isContextProvider = (component: Component) =>\n  (component.formulas &&\n    Object.values(component.formulas).some(\n      ({ exposeInContext }) => exposeInContext,\n    )) ||\n  (component.workflows &&\n    Object.values(component.workflows).some(\n      ({ exposeInContext }) => exposeInContext,\n    ))\n", "import type {\n  Component,\n  ComponentData,\n} from '@toddledev/core/dist/component/component.types'\nimport type { FormulaContext } from '@toddledev/core/dist/formula/formula'\nimport { applyFormula } from '@toddledev/core/dist/formula/formula'\nimport { mapObject } from '@toddledev/core/dist/utils/collections'\nimport { isDefined } from '@toddledev/core/dist/utils/util'\nimport type { Signal } from '../signal/signal'\nimport type { ComponentContext } from '../types'\n\nexport function subscribeToContext(\n  componentDataSignal: Signal<ComponentData>,\n  component: Component,\n  ctx: ComponentContext,\n) {\n  Object.entries(component.contexts ?? {}).forEach(\n    ([providerName, context]) => {\n      const provider =\n        ctx.providers[[ctx.package, providerName].filter(isDefined).join('/')]\n\n      if (provider) {\n        context.formulas.forEach((formulaName) => {\n          const formulaDataSignal = provider.formulaDataSignals[formulaName]\n          if (!formulaDataSignal) {\n            console.warn(\n              `Provider ${providerName} does not expose a formula named \"${formulaName}\". Available formulas are: [\"${Object.keys(\n                provider.formulaDataSignals,\n              ).join('\", \"')}\"]`,\n            )\n            return\n          }\n\n          formulaDataSignal.subscribe((value) => {\n            componentDataSignal.update((data) => ({\n              ...data,\n              Contexts: {\n                ...data.Contexts,\n                [providerName]: {\n                  ...data.Contexts?.[providerName],\n                  [formulaName]: value,\n                },\n              },\n            }))\n          })\n        })\n      }\n\n      // In preview and absence of a real provider, we fake providers with their testData values. This is useful for testing components in isolation.\n      // This is for preview mode only, and should preferably be stripped from the page and custom-elements runtime.\n      else if (\n        !provider &&\n        ctx.env.runtime === 'preview' &&\n        ctx.toddle._preview\n      ) {\n        const testProvider = ctx.components?.find(\n          (comp) =>\n            comp.name ===\n            [ctx.package, providerName].filter(isDefined).join('/'),\n        )\n\n        if (!testProvider) {\n          console.error(\n            `Could not find provider \"${providerName}\". No such component exist.`,\n          )\n          return\n        }\n\n        // Derive the package name from the provider name as we do not have a real component to work with\n        const [, testProviderPackage] = providerName.split('/').reverse()\n        const formulaContext: FormulaContext = {\n          data: {\n            Attributes: mapObject(testProvider.attributes, ([name, attr]) => [\n              name,\n              attr.testValue,\n            ]),\n          },\n          component: testProvider,\n          root: ctx?.root,\n          formulaCache: {},\n          package: testProviderPackage ?? ctx?.package,\n          toddle: ctx.toddle,\n          env: ctx.env,\n        }\n\n        if (testProvider.route) {\n          formulaContext.data['URL parameters'] = {\n            ...Object.fromEntries(\n              testProvider.route.path\n                .filter((p) => p.type === 'param')\n                .map((p) => [p.name, p.testValue]),\n            ),\n            ...mapObject(testProvider.route.query, ([name, { testValue }]) => [\n              name,\n              testValue,\n            ]),\n          }\n        }\n        formulaContext.data.Variables = mapObject(\n          testProvider.variables,\n          ([name, variable]) => [\n            name,\n            applyFormula(variable.initialValue, formulaContext),\n          ],\n        )\n\n        componentDataSignal.update((data) => ({\n          ...data,\n          Contexts: {\n            ...data.Contexts,\n            [providerName]: Object.fromEntries(\n              context.formulas.map((formulaName) => {\n                const formula = testProvider.formulas?.[formulaName]\n                if (!formula) {\n                  console.warn(\n                    `Could not find formula \"${formulaName}\" in component \"${providerName}\"`,\n                  )\n                  return [formulaName, null]\n                }\n\n                return [\n                  formulaName,\n                  applyFormula(formula.formula, formulaContext),\n                ]\n              }),\n            ),\n          },\n        }))\n      }\n    },\n  )\n}\n", "import type {\n  Component,\n  ComponentData,\n} from '@toddledev/core/dist/component/component.types'\nimport type { Signal } from '../signal/signal'\n\nexport function initLogState() {\n  ;(window as any).logState = () => {\n    console.table(\n      Object.entries(window.__components ?? {}).map(([name, sig]) => {\n        return {\n          name,\n          ...(sig as any).get(),\n        }\n      }),\n    )\n  }\n}\n\nexport function registerComponentToLogState(\n  component: Component,\n  dataSignal: Signal<ComponentData>,\n) {\n  if (!window.__components) {\n    window.__components = {}\n  }\n\n  window.__components[component.name] = dataSignal\n}\n", "import type {\n  Component,\n  ComponentData,\n} from '@toddledev/core/dist/component/component.types'\nimport type {\n  Formula,\n  FunctionOperation,\n} from '@toddledev/core/dist/formula/formula'\nimport { get, mapObject } from '@toddledev/core/dist/utils/collections'\nimport { isDefined } from '@toddledev/core/dist/utils/util'\nimport type { FormulaCache } from '../types'\n\nexport function createFormulaCache(component: Component): FormulaCache {\n  if (!isDefined(component.formulas)) {\n    return {}\n  }\n  return mapObject(component.formulas, ([name, f]) => {\n    const { canCache, keys } = f.memoize\n      ? getFormulaCacheConfig(f.formula, component)\n      : { canCache: false, keys: [] }\n    let cacheInput: any\n    let cacheData: any\n\n    return [\n      name,\n      {\n        get: (data: ComponentData) => {\n          if (\n            canCache &&\n            cacheInput &&\n            keys.every((key) => {\n              return get(data, key) === get(cacheInput, key)\n            })\n          ) {\n            return { hit: true, data: cacheData }\n          }\n          return { hit: false }\n        },\n        set: (data: ComponentData, result: any) => {\n          if (canCache) {\n            cacheInput = data\n            cacheData = result\n          }\n        },\n      },\n    ]\n  })\n}\n\nfunction getFormulaCacheConfig(formula: Formula, component: Component) {\n  const paths: string[][] = []\n  function visitOperation(op: Formula) {\n    if (!op) {\n      return\n    }\n    if (op.type == 'path' && op.path[0] !== 'Args') {\n      paths.push(op.path)\n    }\n    if (Array.isArray((op as any)?.arguments)) {\n      ;(op as FunctionOperation)?.arguments.forEach((arg) =>\n        visitOperation(arg.formula),\n      )\n    }\n    if (op.type === 'record' && Array.isArray(op.entries)) {\n      op.entries.forEach((arg) => visitOperation(arg.formula))\n    }\n\n    if (op.type === 'apply') {\n      if (!component.formulas?.[op.name]?.memoize) {\n        throw new Error('Cannot memoize')\n      }\n      visitOperation(component.formulas?.[op.name]?.formula)\n    }\n  }\n  try {\n    visitOperation(formula)\n  } catch {\n    return {\n      canCache: false,\n      keys: [],\n    }\n  }\n\n  const keys: string[][] = []\n  paths\n    .sort((a, b) => a.length - b.length)\n    .forEach((path) => {\n      if (!keys.some((key) => key.every((k, i) => k === path[i]))) {\n        keys.push(path)\n      }\n    })\n  return {\n    canCache: true,\n    keys,\n  }\n}\n", "import type {\n  ElementNodeModel,\n  NodeModel,\n} from '@toddledev/core/dist/component/component.types'\nimport { applyFormula } from '@toddledev/core/dist/formula/formula'\nimport {\n  getClassName,\n  toValidClassName,\n} from '@toddledev/core/dist/styling/className'\nimport { isDefined, toBoolean } from '@toddledev/core/dist/utils/util'\nimport { handleAction } from '../events/handleAction'\nimport type { Signal } from '../signal/signal'\nimport type { SupportedNamespaces } from '../types'\nimport { getDragData } from '../utils/getDragData'\nimport { getElementTagName } from '../utils/getElementTagName'\nimport { setAttribute } from '../utils/setAttribute'\nimport type { NodeRenderer } from './createNode'\nimport { createNode } from './createNode'\n\nexport function createElement({\n  node,\n  dataSignal,\n  id,\n  path,\n  ctx,\n  namespace,\n  instance,\n}: NodeRenderer<ElementNodeModel>): Element {\n  const tag = getElementTagName(node, ctx, id)\n  switch (tag) {\n    case 'svg': {\n      namespace = 'http://www.w3.org/2000/svg'\n      break\n    }\n    case 'math': {\n      namespace = 'http://www.w3.org/1998/Math/MathML'\n      break\n    }\n  }\n\n  // Explicitly setting a namespace has precedence over inferring it from the tag\n  if (node.attrs['xmlns'] && node.attrs['xmlns'].type === 'value') {\n    namespace = String(node.attrs['xmlns'].value) as SupportedNamespaces\n  }\n\n  const elem = namespace\n    ? (document.createElementNS(namespace, tag) as SVGElement | MathMLElement)\n    : document.createElement(tag)\n\n  elem.setAttribute('data-node-id', id)\n  if (path) {\n    elem.setAttribute('data-id', path)\n  }\n  if (ctx.isRootComponent === false && id !== 'root') {\n    elem.setAttribute('data-component', ctx.component.name)\n  }\n  const classHash = getClassName([node.style, node.variants])\n  elem.classList.add(classHash)\n  if (instance && id === 'root') {\n    Object.entries(instance).forEach(([key, value]) => {\n      elem.classList.add(toValidClassName(`${key}:${value}`))\n    })\n  }\n  if (node.classes) {\n    Object.entries(node.classes)?.forEach(([className, { formula }]) => {\n      if (formula) {\n        const classSignal = dataSignal.map((data) =>\n          toBoolean(\n            applyFormula(formula, {\n              data,\n              component: ctx.component,\n              formulaCache: ctx.formulaCache,\n              root: ctx.root,\n              package: ctx.package,\n              toddle: ctx.toddle,\n              env: ctx.env,\n            }),\n          ),\n        )\n        classSignal.subscribe((show) =>\n          show\n            ? elem.classList.add(className)\n            : elem.classList.remove(className),\n        )\n      } else {\n        elem.classList.add(className)\n      }\n    })\n  }\n\n  Object.entries(node.attrs).forEach(([attr, value]) => {\n    if (!isDefined(value)) {\n      return\n    }\n    let o: Signal<any> | undefined\n    const setupAttribute = () => {\n      if (value.type === 'value') {\n        setAttribute(elem, attr, value?.value)\n      } else {\n        o = dataSignal.map((data) =>\n          applyFormula(value, {\n            data,\n            component: ctx.component,\n            formulaCache: ctx.formulaCache,\n            root: ctx.root,\n            package: ctx.package,\n            toddle: ctx.toddle,\n            env: ctx.env,\n          }),\n        )\n        o.subscribe((val) => {\n          setAttribute(elem, attr, val)\n        })\n      }\n    }\n    if (\n      attr === 'autofocus' &&\n      ctx.env.runtime === 'preview' &&\n      ctx.toddle._preview\n    ) {\n      ctx.toddle._preview.showSignal.subscribe(({ testMode }) => {\n        if (testMode) {\n          setupAttribute()\n        } else {\n          o?.destroy()\n          elem.removeAttribute(attr)\n        }\n      })\n    } else {\n      setupAttribute()\n    }\n  })\n  node['style-variables']?.forEach(({ formula, name, unit }) => {\n    const sig = dataSignal.map((data) => {\n      const value = applyFormula(formula, {\n        data,\n        component: ctx.component,\n        formulaCache: ctx.formulaCache,\n        root: ctx.root,\n        package: ctx.package,\n        toddle: ctx.toddle,\n        env: ctx.env,\n      })\n      return unit ? value + unit : value\n    })\n    sig.subscribe((value) => elem.style.setProperty(`--${name}`, value))\n  })\n  Object.values(node.events).forEach((event) => {\n    const handler = (e: Event) => {\n      event.actions.forEach((action) => {\n        if (e instanceof DragEvent) {\n          ;(e as any).data = getDragData(e)\n        }\n        if (e instanceof ClipboardEvent) {\n          try {\n            ;(e as any).data = Array.from(e.clipboardData?.items ?? []).reduce<\n              Record<string, any>\n            >((dragData, item) => {\n              try {\n                dragData[item.type] = JSON.parse(\n                  e.clipboardData?.getData(item.type) as any,\n                )\n              } catch {\n                dragData[item.type] = e.clipboardData?.getData(item.type)\n              }\n              return dragData\n            }, {})\n          } catch (e) {\n            console.error('Could not get paste data')\n            console.error(e)\n          }\n        }\n        void handleAction(action, { ...dataSignal.get(), Event: e }, ctx, e)\n      })\n      return false\n    }\n    elem.addEventListener(event.trigger, handler)\n  })\n\n  // for script, style & SVG<text> tags we only render text child.\n  // this can be removed once we fix the editor to handle raw text nodes without wrapping <span>\n  const nodeTag = node.tag.toLocaleLowerCase()\n  if (nodeTag === 'script' || nodeTag === 'style') {\n    const textValues: Array<Signal<string> | string> = []\n    node.children\n      .map<NodeModel | undefined>((child) => ctx.component.nodes[child])\n      .filter((node) => node?.type === 'text')\n      .forEach((node) => {\n        if (node.value.type === 'value') {\n          textValues.push(String(node.value.value))\n        } else {\n          const textSignal = dataSignal.map((data) => {\n            return String(\n              applyFormula(node.value, {\n                data,\n                component: ctx.component,\n                formulaCache: ctx.formulaCache,\n                root: ctx.root,\n                package: ctx.package,\n                toddle: ctx.toddle,\n                env: ctx.env,\n              }),\n            )\n          })\n          textValues.push(textSignal)\n        }\n      })\n\n    // if all values are string, we can directly set textContent\n    if (textValues.every((value) => typeof value === 'string')) {\n      elem.textContent = textValues.join('')\n    }\n\n    // for each signal, we subscribe and rewrite the entire textContent from all text nodes\n    textValues\n      .filter((value) => typeof value !== 'string')\n      .forEach((valueSignal) => {\n        valueSignal.subscribe(() => {\n          elem.textContent = textValues\n            .map((value) => (typeof value === 'string' ? value : value.get()))\n            .join('')\n        })\n      })\n  } else {\n    node.children.forEach((child, i) => {\n      const childNodes = createNode({\n        parentElement: elem,\n        id: child,\n        path: path + '.' + i,\n        dataSignal,\n        ctx,\n        namespace,\n        instance,\n      })\n      childNodes.forEach((childNode) => elem.appendChild(childNode))\n    })\n  }\n\n  return elem\n}\n", "export function getDragData(event: Event) {\n  if (event instanceof DragEvent) {\n    return Array.from(event.dataTransfer?.items ?? []).reduce<\n      Record<string, any>\n    >((dragData, item) => {\n      dragData[item.type] = event.dataTransfer?.getData(item.type)\n      return dragData\n    }, {})\n  }\n  return\n}\n", "import type { ElementNodeModel } from '@toddledev/core/dist/component/component.types'\nimport type { ComponentContext } from '../types'\n\nexport function getElementTagName(\n  node: ElementNodeModel,\n  ctx: ComponentContext,\n  id: string,\n) {\n  if (ctx.component.version === 2 && id === 'root') {\n    return `${ctx.package ?? ctx.toddle.project}-${node.tag}`\n  }\n\n  return node.tag\n}\n", "import { isDefined, toBoolean } from '@toddledev/core/dist/utils/util'\n\n/**\n * Some attributes need special handling.\n */\nexport function setAttribute(\n  elem: HTMLElement | SVGElement | MathMLElement,\n  attr: string,\n  value: any,\n) {\n  switch (attr) {\n    case 'srcObject':\n    case 'src':\n      if (elem instanceof HTMLMediaElement) {\n        ;(elem as any)[attr] = value\n      } else {\n        elem.setAttribute(attr, String(value))\n      }\n      break\n    case 'value':\n    case 'type': {\n      let val = value\n      if (elem instanceof HTMLProgressElement) {\n        // An HTMLProgressElement will break other elements in our editor if the value is not a (finite) number\n        // See docs here https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress#value\n        // and original issue here https://discord.com/channels/972416966683926538/1317827591230722048\n        if (!isDefined(value) || !Number.isFinite(Number(value))) {\n          val = 0\n        }\n      }\n      ;(elem as any)[attr] = toBoolean(val) ? String(val) : undefined\n      break\n    }\n    case 'muted':\n    case 'autoplay':\n      if (elem instanceof HTMLMediaElement) {\n        ;(elem as any)[attr] = toBoolean(value)\n      } else {\n        elem.setAttribute(attr, String(value))\n      }\n      break\n    default:\n      if (toBoolean(value)) {\n        elem.setAttribute(attr, String(value))\n        if (\n          // autofocus often does not work in the editor\n          attr === 'autofocus' &&\n          document.body.getAttribute('data-mode') !== 'design'\n        ) {\n          setTimeout(() => elem.focus(), 100)\n        }\n      } else {\n        elem.removeAttribute(attr)\n      }\n  }\n}\n", "import type { SlotNodeModel } from '@toddledev/core/dist/component/component.types'\nimport type { NodeRenderer } from './createNode'\nimport { createNode } from './createNode'\n\nexport function createSlot({\n  path,\n  node,\n  dataSignal,\n  ctx,\n  parentElement,\n  instance,\n  namespace,\n}: NodeRenderer<SlotNodeModel>): ReadonlyArray<Element | Text> {\n  const slotName = node.name ?? 'default'\n  let children: Array<Element | Text> = []\n  // Is slotted content provided?\n  if (ctx.children[slotName]) {\n    children = ctx.children[slotName].flatMap((child) => {\n      const childDataSignal = child.dataSignal.map((data) => data)\n      dataSignal.subscribe((data) => data, {\n        destroy: () => childDataSignal.destroy(),\n      })\n      return createNode({\n        ...child,\n        dataSignal: childDataSignal,\n        parentElement,\n        ctx: {\n          ...child.ctx,\n          providers: ctx.providers,\n        },\n        instance,\n        namespace,\n      })\n    })\n  } else {\n    // Otherwise, return placeholder content\n    children = node.children.flatMap((child, i) => {\n      return createNode({\n        id: child,\n        path: path + '.' + i,\n        dataSignal,\n        ctx,\n        parentElement,\n        instance,\n        namespace,\n      })\n    })\n  }\n\n  if (ctx.env.runtime === 'custom-element' && ctx.isRootComponent) {\n    const webComponentSlot = document.createElement('slot')\n    webComponentSlot.setAttribute('name', slotName)\n    children.forEach((child) => {\n      webComponentSlot.appendChild(child)\n    })\n\n    return [webComponentSlot]\n  }\n\n  return children\n}\n", "import type {\n  ComponentData,\n  TextNodeModel,\n} from '@toddledev/core/dist/component/component.types'\nimport { applyFormula } from '@toddledev/core/dist/formula/formula'\nimport type { Signal } from '../signal/signal'\nimport type { ComponentContext, SupportedNamespaces } from '../types'\n\nexport type RenderTextProps = {\n  node: TextNodeModel\n  dataSignal: Signal<ComponentData>\n  id: string\n  path: string\n  namespace?: SupportedNamespaces\n  ctx: ComponentContext\n}\n\n/**\n * Create a text node\n *\n * Note: We wrap the text in a <span> to make it easier to select/highlight the text node in the preview.\n * We should find a better way to do this without wrapping the node, and instead use `createTextNode`.\n */\nexport function createText({\n  node,\n  id,\n  path,\n  dataSignal,\n  namespace,\n  ctx,\n}: RenderTextProps): HTMLSpanElement | Text {\n  // Span element is not valid outside of the default namespace\n  if (namespace && namespace !== 'http://www.w3.org/1999/xhtml') {\n    return createTextNS({ node, dataSignal, ctx })\n  }\n\n  const { value } = node\n  const elem = document.createElement('span')\n  elem.setAttribute('data-node-id', id)\n  if (typeof id === 'string') {\n    elem.setAttribute('data-id', path)\n  }\n  if (ctx.isRootComponent === false) {\n    elem.setAttribute('data-component', ctx.component.name)\n  }\n  elem.setAttribute('data-node-type', 'text')\n  if (value.type !== 'value') {\n    const sig = dataSignal.map((data) =>\n      String(\n        applyFormula(value, {\n          data,\n          component: ctx.component,\n          formulaCache: ctx.formulaCache,\n          root: ctx.root,\n          package: ctx.package,\n          toddle: ctx.toddle,\n          env: ctx.env,\n        }),\n      ),\n    )\n    sig.subscribe((value) => {\n      elem.innerText = value\n    })\n  } else {\n    elem.innerText = String(value.value)\n  }\n  return elem\n}\n\n/**\n * This function is technically more performant than `createText` because it doesn't create a wrapping <span> element.\n * We would like to use this everywhere eventually, but we need to handle raw text selection in the editor (possibly by utilizing text ranges).\n */\nexport function createTextNS({\n  node,\n  dataSignal,\n  ctx,\n}: Pick<RenderTextProps, 'node' | 'dataSignal' | 'ctx'>): Text {\n  const { value } = node\n  const textNode = document.createTextNode('')\n  if (value.type !== 'value') {\n    const sig = dataSignal.map((data) =>\n      String(\n        applyFormula(value, {\n          data,\n          component: ctx.component,\n          formulaCache: ctx.formulaCache,\n          root: ctx.root,\n          package: ctx.package,\n          toddle: ctx.toddle,\n          env: ctx.env,\n        }),\n      ),\n    )\n    sig.subscribe((value) => {\n      textNode.nodeValue = value\n    })\n  } else {\n    textNode.nodeValue = String(value.value)\n  }\n\n  return textNode\n}\n"],
  "mappings": "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",
  "names": ["isDefined", "value", "exports", "isObject", "input", "toBoolean", "isToddleFormula", "formula", "exports", "exports", "isFormula", "isFormulaApplyOperation", "applyFormula", "util_1", "formulaTypes_1", "f", "formula", "ctx", "input", "key", "branch", "entry", "packageName", "newFunc", "legacyFunc", "args", "arg", "i", "Args", "e", "componentFormula", "Input", "data", "cache", "result", "exports", "get", "util_1", "isObject", "input", "mapObject", "object", "f", "mapValues", "key", "value", "omit", "collection", "head", "rest", "clone", "omitKeys", "keys", "k", "omitPaths", "acc", "groupBy", "items", "item", "filterObject", "set", "sortObjectEntries", "ascending", "easySort", "a", "b", "keyA", "keyB", "deepSortObject", "obj", "val", "hash", "data", "seed", "h1", "h2", "i", "ch", "exports", "ApiMethod", "exports", "exports", "getFormulasInFormula", "getFormulasInAction", "util_1", "formula_1", "formulaTypes_1", "valueFormula", "value", "pathFormula", "path", "functionFormula", "name", "formula", "globalFormulas", "visitedFormulas", "key", "entry", "formulaKey", "shouldVisitFormula", "globalFormula", "arg", "c", "action", "inputKey", "input", "eventKey", "event", "a", "actionKey", "formula_1", "formulaUtils_1", "util_1", "LegacyToddleApi", "api", "key", "globalFormulas", "apis", "visitFormulaReference", "formula", "entry", "arg", "c", "p", "q", "h", "apiKey", "pathKey", "path", "queryParamKey", "queryParam", "headerKey", "header", "actionKey", "action", "exports", "exports", "getActionsInAction", "util_1", "action", "path", "key", "a", "eventKey", "event", "c", "actionKey", "actionUtils_1", "formulaUtils_1", "util_1", "ToddleApiV2", "api", "apiKey", "globalFormulas", "apis", "visitFormulaReference", "formula", "entry", "arg", "c", "p", "h", "q", "rule", "headers", "input", "value", "pathKey", "path", "queryParamKey", "queryParam", "headerKey", "header", "actionKey", "action", "exports", "formula_1", "collections_1", "hash_1", "util_1", "apiTypes_1", "LegacyToddleApi_1", "ToddleApiV2_1", "exports", "isLegacyApi", "api", "createApiRequest", "formulaContext", "baseUrl", "defaultHeaders", "url", "requestSettings", "getRequestSettings", "getUrl", "urlPathname", "urlQueryParams", "parsedUrl", "urlInput", "pathParams", "path", "queryParams", "queryString", "combinedUrl", "HttpMethodsWithAllowedBody", "applyAbortSignal", "timeout", "method", "headers", "body", "getRequestBody", "getRequestPath", "_", "p", "getRequestQueryParams", "params", "key", "param", "value", "v", "encodeObject", "obj", "prefix", "val", "getRequestHeaders", "apiHeaders", "getBaseUrl", "origin", "requestHash", "request", "isApiError", "apiName", "response", "errorFormula", "performance", "errorFormulaRes", "formData", "createApiEvent", "eventName", "detail", "compareApiDependencies", "a", "b", "isADependentOnB", "isBDependentOnA", "sortApiObjects", "apis", "apiMap", "getApi", "apiObj", "aKey", "aObj", "bKey", "bObj", "sortApiEntries", "__", "exports", "parseJSONWithDate", "iso8601Regex", "input", "_", "value", "STRING_TEMPLATE", "type", "name", "templateTypes", "exports", "require_fast_deep_equal", "__commonJSMin", "exports", "module", "equal", "a", "b", "length", "i", "keys", "key", "isJsonHeader", "header", "exports", "isTextHeader", "isEventStreamHeader", "isJsonStreamHeader", "isImageHeader", "LOCALHOSTS", "isLocalhostUrl", "hrefOrOrigin", "host", "exports", "isLocalhostHostname", "hostname", "validateUrl", "url", "base", "urlObject", "value", "key", "SEED", "phash", "h", "x", "i", "hash", "AD_REPLACER_R", "charsLength", "getAlphabeticChar", "code", "generateAlphabeticName", "name", "getClassName", "object", "exports", "toValidClassName", "input", "escapeSpecialCharacters", "className", "match", "import_api", "import_formula", "import_collections", "import_util", "actions_exports", "__export", "handler_exports", "handler_exports", "__export", "handler_default", "import_util", "handler", "delay", "ctx", "delayNumber", "timeout", "handler_exports", "__export", "handler_default", "handler", "key", "handler_exports", "__export", "handler_default", "import_util", "handler", "url", "title", "text", "validInput", "value", "data", "handler_exports", "__export", "handler_default", "handler", "key", "value", "handler_exports", "__export", "handler_default", "handler", "_", "_ctx", "event", "handler_exports", "__export", "handler_default", "import_util", "handler", "delay", "ctx", "delayNumber", "interval", "handler_exports", "__export", "handler_default", "handler", "handler_exports", "__export", "handler_default", "handler", "key", "handler_exports", "__export", "handler_default", "handler", "label", "data", "handler_exports", "__export", "handler_default", "handler", "value", "handler_exports", "__export", "handler_default", "handler", "access_token", "ttl", "ctx", "query", "res", "handler_exports", "__export", "handler_default", "handler", "key", "value", "handler_exports", "__export", "handler_default", "handler", "elem", "handler_exports", "__export", "handler_default", "handler", "handler_exports", "__export", "handler_default", "handler", "url", "ctx", "handler_exports", "__export", "handler_default", "handler", "_", "_ctx", "event", "formulas_exports", "__export", "handler_exports", "handler_exports", "__export", "handler_default", "handler", "a", "b", "handler_exports", "__export", "handler_default", "getArgumentInputData", "handler", "items", "fx", "item", "index", "key", "value", "argIndex", "input", "first", "handler_exports", "__export", "handler_default", "handler", "_", "env", "handler_exports", "__export", "handler_default", "handler", "input", "decimals", "multiplier", "handler_exports", "__export", "handler_default", "import_util", "handler", "values", "value", "handler_exports", "__export", "handler_default", "handler", "numbers", "n", "product", "num", "handler_exports", "__export", "handler_default", "handler", "handler_exports", "__export", "handler_default", "getArgumentInputData", "handler", "items", "fx", "init", "result", "item", "index", "key", "value", "_", "argIndex", "input", "first", "handler_exports", "__export", "handler_default", "handler", "collection", "item", "collectionItem", "handler_exports", "__export", "handler_default", "handler", "args", "handler_exports", "__export", "handler_default", "handler", "input", "handler_exports", "__export", "handler_default", "handler", "URIComponent", "handler_exports", "__export", "handler_default", "getArgumentInputData", "handler", "array", "formula", "ascending", "ascendingModifier", "a", "b", "keyA", "keyB", "i", "items", "argIndex", "input", "handler_exports", "__export", "handler_default", "getArgumentInputData", "handler", "items", "fx", "item", "index", "key", "value", "argIndex", "input", "first", "handler_exports", "__export", "handler_default", "handler", "input", "decimals", "multiplier", "handler_exports", "__export", "handler_default", "import_util", "handler", "a", "handler_exports", "__export", "handler_default", "import_util", "handler", "url", "title", "text", "validInput", "value", "data", "handler_exports", "__export", "handler_default", "handler", "URIComponent", "handler_exports", "__export", "handler_default", "import_util", "handler", "collection", "key", "value", "ctx", "head", "rest", "clone", "handler_exports", "__export", "handler_default", "handler", "first", "second", "handler_exports", "__export", "handler_default", "handler", "list", "object", "key", "value", "handler_exports", "__export", "handler_default", "getArgumentInputData", "handler", "items", "func", "item", "index", "key", "value", "argIndex", "input", "first", "handler_exports", "__export", "handler_default", "getArgumentInputData", "handler", "items", "fx", "item", "index", "key", "value", "argIndex", "input", "first", "handler_exports", "__export", "handler_default", "handler", "url", "base", "hostname", "searchParams", "pathname", "hash", "href", "protocol", "port", "origin", "p", "handler_exports", "__export", "handler_default", "handler", "list", "count", "handler_exports", "__export", "handler_default", "handler", "list", "handler_exports", "__export", "handler_default", "handler", "value", "min", "max", "handler_exports", "__export", "handler_default", "handler", "_", "env", "handler_exports", "__export", "handler_default", "getArgumentInputData", "handler", "items", "fx", "item", "index", "key", "value", "res", "argIndex", "input", "first", "handler_exports", "__export", "handler_default", "handler", "a", "b", "handler_exports", "__export", "handler_default", "handler", "id", "root", "handler_exports", "__export", "handler_default", "handler", "input", "searchValue", "replaceValue", "handler_exports", "__export", "handler_default", "getArgumentInputData", "handler", "items", "fx", "item", "index", "key", "value", "argIndex", "input", "first", "handler_exports", "__export", "handler_default", "handler", "_", "ctx", "handler_exports", "__export", "handler_default", "handler", "input", "handler_exports", "__export", "handler_default", "handler", "input", "handler_exports", "__export", "handler_default", "import_util", "handler", "items", "result", "item", "handler_exports", "__export", "handler_default", "handler", "data", "indent", "handler_exports", "__export", "handler_default", "handler", "key", "value", "handler_exports", "__export", "handler_default", "handler", "a", "b", "handler_exports", "__export", "handler_default", "handler", "list", "set", "item", "key", "handler_exports", "__export", "handler_default", "handler", "list", "handler_exports", "__export", "handler_default", "handler", "list", "handler_exports", "__export", "handler_default", "handler", "a", "b", "first", "second", "handler_exports", "__export", "handler_default", "getArgumentInputData", "handler", "items", "func", "res", "index", "item", "key", "argIndex", "input", "handler_exports", "__export", "handler_default", "handler", "collection", "key", "resolve", "path", "head", "rest", "handler_exports", "__export", "handler_default", "handler", "list", "value", "handler_exports", "__export", "handler_default", "handler", "a", "b", "handler_exports", "__export", "handler_default", "handler", "date", "handler_exports", "__export", "handler_default", "handler", "value", "handler_exports", "__export", "handler_default", "handler", "list", "count", "handler_exports", "__export", "handler_default", "handler", "a", "handler_exports", "__export", "handler_default", "handler", "list", "count", "handler_exports", "__export", "handler_default", "import_util", "handler", "collection", "key", "run", "path", "index", "_", "i", "e", "k", "handler_exports", "__export", "handler_default", "handler", "date", "handler_exports", "__export", "handler_default", "handler", "object", "key", "value", "handler_exports", "__export", "handler_default", "handler", "str", "handler_exports", "__export", "handler_default", "handler", "items", "handler_exports", "__export", "handler_default", "handler", "data", "indentation", "indent", "handler_exports", "__export", "handler_default", "handler", "first", "second", "handler_exports", "__export", "handler_default", "handler", "handler_exports", "__export", "handler_default", "handler", "n", "handler_exports", "__export", "handler_default", "handler", "list", "count", "handler_exports", "__export", "handler_default", "handler", "list", "value", "handler_exports", "__export", "handler_default", "handler", "key", "value", "handler_exports", "__export", "handler_default", "handler", "a", "handler_exports", "__export", "handler_default", "handler", "input", "handler_exports", "__export", "handler_default", "handler", "list", "separator", "handler_exports", "__export", "handler_default", "handler", "min", "max", "_", "i", "handler_exports", "__export", "handler_default", "handler", "args", "handler_exports", "__export", "handler_default", "handler", "first", "second", "handler_exports", "__export", "handler_default", "handler", "list", "shuffle", "input", "array", "i", "j", "handler_exports", "__export", "handler_default", "handler", "collection", "item", "i", "handler_exports", "__export", "handler_default", "handler", "a", "b", "handler_exports", "__export", "handler_default", "handler", "input", "decimals", "multiplier", "handler_exports", "__export", "handler_default", "getArgumentInputData", "handler", "items", "fx", "item", "index", "key", "value", "argIndex", "input", "first", "handler_exports", "__export", "handler_default", "getArgumentInputData", "handler", "items", "func", "list", "res", "i", "item", "key", "argIndex", "input", "first", "handler_exports", "__export", "handler_default", "import_json", "handler", "data", "handler_exports", "__export", "handler_default", "handler", "date", "loc", "opt", "locales", "l", "validateString", "value", "allowedValues", "options", "dateStyle", "timeStyle", "calendar", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "timeZone", "hour12", "handler_exports", "__export", "handler_default", "import_util", "handler", "inputString", "regex", "globalFlag", "ignoreCaseFlag", "multiLineFlag", "flags", "re", "handler_exports", "__export", "handler_default", "handler", "list", "sum", "n", "handler_exports", "__export", "handler_default", "handler", "collection", "prefix", "handler_exports", "__export", "handler_default", "handler", "timestamp", "handler_exports", "__export", "handler_default", "handler", "_", "env", "lang", "handler_exports", "__export", "handler_default", "handler", "inputString", "delimiter", "handler_exports", "__export", "handler_default", "import_util", "handler", "collection", "handler_exports", "__export", "handler_default", "handler", "_", "ctx", "handler_exports", "__export", "handler_default", "handler", "name", "env", "root", "row", "handler_exports", "__export", "handler_default", "import_util", "handler", "input", "handler_exports", "__export", "handler_default", "handler", "collection", "item", "i", "handler_exports", "__export", "handler_default", "handler", "input", "handler_exports", "__export", "handler_default", "handler", "input", "handler_exports", "__export", "handler_default", "import_template", "handler", "name", "handler_exports", "__export", "handler_default", "handler", "input", "loc", "opt", "locales", "l", "validateString", "value", "allowedValues", "options", "style", "currency", "currencyDisplay", "unit", "unitDisplay", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "notation", "compactDisplay", "validGroupingValues", "useGrouping", "handler_exports", "__export", "handler_default", "handler", "numbers", "n", "result", "handler_exports", "__export", "handler_default", "handler", "first", "second", "import_fast_deep_equal", "lexer", "str", "tokens", "i", "char", "name", "j", "code", "count", "pattern", "parse", "options", "_a", "prefixes", "_b", "delimiter", "result", "key", "path", "tryConsume", "type", "mustConsume", "value", "nextType", "index", "consumeText", "isSafe", "_i", "delimiter_1", "safePattern", "prefix", "prev", "prevText", "escapeString", "open", "name_1", "pattern_1", "suffix", "compile", "tokensToFunction", "reFlags", "flags", "encode", "x", "validate", "matches", "token", "data", "optional", "repeat", "segment", "typeOfMessage", "match", "keys", "re", "pathToRegexp", "regexpToFunction", "decode", "pathname", "m", "params", "regexpToRegexp", "groupsRegex", "execResult", "arrayToRegexp", "paths", "parts", "stringToRegexp", "tokensToRegexp", "strict", "start", "_c", "end", "_d", "_e", "_f", "endsWith", "endsWithRe", "delimiterRe", "route", "tokens_1", "mod", "endToken", "isEndDelimited", "import_formula", "import_collections", "import_json", "import_formula", "import_collections", "import_util", "handleAction", "action", "data", "ctx", "event", "actionList", "condition", "value", "payload", "current", "p", "api", "isv2", "actionInputs", "input", "actionModels", "triggerActions", "actions", "subAction", "parameters", "parameter", "provider", "workflow", "triggerActionEvent", "trigger", "eventData", "subEvent", "newAction", "args", "arg", "result", "cleanup", "err", "legacyHandler", "e", "createLegacyAPI", "api", "ctx", "timer", "constructPayload", "data", "formulaContext", "baseUrl", "urlPath", "p", "queryParams", "queryString", "param", "headers", "value", "contentType", "key", "method", "body", "encodeBody", "getBody", "res", "textBody", "v", "formData", "apiSuccess", "action", "handleAction", "apiError", "error", "execute", "payload", "response", "trigger", "resolve", "reject", "payloadSignal", "firstRun", "cached", "request", "apiPayload", "acc", "import_api", "import_headers", "import_formula", "import_collections", "import_url", "createAPI", "apiRequest", "ctx", "timer", "api", "constructRequest", "baseUrl", "getFormulaContext", "formulaContext", "evaluatedInputs", "acc", "key", "value", "data", "handleRedirectRules", "ruleName", "rule", "_", "location", "url", "triggerActions", "eventName", "event", "action", "handleAction", "apiSuccess", "performance", "latestRequestStart", "appliedRedirectRule", "apiError", "execute", "requestSettings", "run", "response", "proxyUrl", "headers", "handleResponse", "error", "body", "resolve", "reject", "res", "parserMode", "contentType", "textStreamResponse", "jsonResponse", "eventStreamingResponse", "jsonStreamResponse", "blobResponse", "handleStreaming", "chunk", "chunks", "parsedData", "status", "endResponse", "blob", "id", "retry", "streamType", "useTextDecoder", "parseChunk", "parseChunksForData", "delimiters", "parsedChunk", "delimiter", "d", "concatenated", "split", "c", "reader", "done", "parsed", "apiStatus", "getApiForComparison", "payloadSignal", "payloadContext", "cacheKey", "cacheMatch", "actionInputs", "actionModels", "inputs", "inputName", "input", "apiWithInputsAndActions", "newApi", "updateContext", "autoFetch", "apiData", "import_fast_deep_equal", "BatchQueue", "callback", "import_formula", "import_util", "import_fast_deep_equal", "Signal", "value", "deepEqual", "notify", "f", "config", "subscriber", "destroy", "signal2", "signal", "getNextSiblingElement", "path", "parentElement", "lastPathPart", "index", "repeatIndex", "child", "lastChildPathPart", "childIndex", "ensureEfficientOrdering", "items", "nextElement", "insertBeforeElement", "currentMarker", "i", "item", "import_api", "import_formula", "import_collections", "import_util", "isContextProvider", "component", "exposeInContext", "import_formula", "import_collections", "import_util", "subscribeToContext", "componentDataSignal", "component", "ctx", "providerName", "context", "provider", "formulaName", "formulaDataSignal", "value", "data", "testProvider", "comp", "testProviderPackage", "formulaContext", "name", "attr", "p", "testValue", "variable", "formula", "initLogState", "name", "sig", "registerComponentToLogState", "component", "dataSignal", "import_collections", "import_util", "createFormulaCache", "component", "name", "f", "canCache", "keys", "getFormulaCacheConfig", "cacheInput", "cacheData", "data", "key", "result", "formula", "paths", "visitOperation", "op", "arg", "b", "path", "k", "i", "createComponent", "node", "path", "dataSignal", "ctx", "parentElement", "instance", "namespace", "nodeLookupKey", "component", "comp", "c", "attributesSignal", "data", "attr", "value", "componentDataSignal", "signal", "name", "api", "subscribeToContext", "variable", "registerComponentToLogState", "abortController", "formulaCache", "createFormulaCache", "apis", "createLegacyAPI", "eventTrigger", "eventHandler", "e", "action", "handleAction", "createAPI", "onEvent", "providers", "isContextProvider", "formulaDataSignals", "formula", "children", "i", "childId", "slotName", "Attributes", "renderComponent", "import_formula", "import_className", "import_util", "getDragData", "event", "dragData", "item", "getElementTagName", "node", "ctx", "id", "import_util", "setAttribute", "elem", "attr", "value", "val", "createElement", "node", "dataSignal", "id", "path", "ctx", "namespace", "instance", "tag", "getElementTagName", "elem", "classHash", "key", "value", "className", "formula", "data", "show", "attr", "o", "setupAttribute", "setAttribute", "val", "testMode", "name", "unit", "event", "handler", "e", "action", "getDragData", "dragData", "item", "handleAction", "nodeTag", "textValues", "child", "textSignal", "valueSignal", "i", "createNode", "childNode", "createSlot", "path", "node", "dataSignal", "ctx", "parentElement", "instance", "namespace", "slotName", "children", "child", "childDataSignal", "data", "createNode", "i", "webComponentSlot", "import_formula", "createText", "node", "id", "path", "dataSignal", "namespace", "ctx", "createTextNS", "value", "elem", "data", "textNode", "createNode", "id", "dataSignal", "path", "ctx", "namespace", "parentElement", "instance", "node", "create", "props", "createElement", "isLocalComponent", "c", "createComponent", "createText", "createSlot", "conditional", "firstRun", "childDataSignal", "showSignal", "data", "elements", "toggle", "show", "nextPathElement", "getNextSiblingElement", "element", "elem", "displayedNodes", "testMode", "repeat", "repeatItems", "list", "newRepeatItems", "i", "Key", "Item", "childData", "childKey", "existingItem", "signal", "cleanup", "ListItem", "args", "key", "item", "e", "ensureEfficientOrdering", "BATCH_QUEUE", "BatchQueue", "renderComponent", "component", "dataSignal", "onEvent", "isRootComponent", "path", "children", "formulaCache", "components", "apis", "abortSignal", "root", "providers", "packageName", "parentElement", "instance", "toddle", "namespace", "env", "ctx", "rootElem", "createNode", "prev", "data", "props", "action", "handleAction", "changes", "key", "value", "deepEqual", "initLogState", "env", "initGlobalObject", "code", "component", "params", "hash", "query", "parseUrl", "legacyActions", "legacyFormulas", "argumentInputDataList", "toddle", "fastDeepEqual", "name", "handler", "getArgumentInputData", "packageName", "formulaName", "args", "argIndex", "data", "signal", "formulas_exports", "module", "actions_exports", "createRoot", "domNode", "urlSignal", "page", "route", "path", "pathSegments", "segment", "segmentValue", "compile", "hashString", "queryString", "_", "q", "key", "value", "url", "routeSignal", "dataSignal", "variable", "titleFormula", "newTitle", "descriptionFormula", "meta", "dynamicDescription", "dynamicMetaFormulas", "r", "a", "findMetaElement", "el", "updateMetaElement", "entry", "id", "existingElement", "identifier", "newDescription", "descriptionElement", "m", "k", "agg", "formula", "attrs", "registerComponentToLogState", "abortController", "ctx", "event", "api", "createLegacyAPI", "createAPI", "providers", "isContextProvider", "formulaDataSignals", "elements", "renderComponent", "elem", "i", "match", "parseQuery", "defaultQueryParams", "pair"]
}
